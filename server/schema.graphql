# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Actor {
  _count: ActorCount
  actor_id: Int!
  film_actor(cursor: Film_actorWhereUniqueInput, distinct: [Film_actorScalarFieldEnum!], orderBy: [Film_actorOrderByWithRelationInput!], skip: Int, take: Int, where: Film_actorWhereInput): [Film_actor!]!
  first_name: String!
  last_name: String!
  last_update: DateTimeISO!
}

type ActorAvgAggregate {
  actor_id: Float
}

input ActorAvgOrderByAggregateInput {
  actor_id: SortOrder
}

type ActorCount {
  film_actor(where: Film_actorWhereInput): Int!
}

type ActorCountAggregate {
  _all: Int!
  actor_id: Int!
  first_name: Int!
  last_name: Int!
  last_update: Int!
}

input ActorCountOrderByAggregateInput {
  actor_id: SortOrder
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
}

input ActorCreateInput {
  film_actor: Film_actorCreateNestedManyWithoutActorInput
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
}

input ActorCreateManyInput {
  actor_id: Int
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
}

input ActorCreateNestedOneWithoutFilm_actorInput {
  connect: ActorWhereUniqueInput
  connectOrCreate: ActorCreateOrConnectWithoutFilm_actorInput
  create: ActorCreateWithoutFilm_actorInput
}

input ActorCreateOrConnectWithoutFilm_actorInput {
  create: ActorCreateWithoutFilm_actorInput!
  where: ActorWhereUniqueInput!
}

input ActorCreateWithoutFilm_actorInput {
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
}

type ActorGroupBy {
  _avg: ActorAvgAggregate
  _count: ActorCountAggregate
  _max: ActorMaxAggregate
  _min: ActorMinAggregate
  _sum: ActorSumAggregate
  actor_id: Int!
  first_name: String!
  last_name: String!
  last_update: DateTimeISO!
}

type ActorMaxAggregate {
  actor_id: Int
  first_name: String
  last_name: String
  last_update: DateTimeISO
}

input ActorMaxOrderByAggregateInput {
  actor_id: SortOrder
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
}

type ActorMinAggregate {
  actor_id: Int
  first_name: String
  last_name: String
  last_update: DateTimeISO
}

input ActorMinOrderByAggregateInput {
  actor_id: SortOrder
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
}

input ActorOrderByWithAggregationInput {
  _avg: ActorAvgOrderByAggregateInput
  _count: ActorCountOrderByAggregateInput
  _max: ActorMaxOrderByAggregateInput
  _min: ActorMinOrderByAggregateInput
  _sum: ActorSumOrderByAggregateInput
  actor_id: SortOrder
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
}

input ActorOrderByWithRelationInput {
  actor_id: SortOrder
  film_actor: Film_actorOrderByRelationAggregateInput
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
}

input ActorRelationFilter {
  is: ActorWhereInput
  isNot: ActorWhereInput
}

enum ActorScalarFieldEnum {
  actor_id
  first_name
  last_name
  last_update
}

input ActorScalarWhereWithAggregatesInput {
  AND: [ActorScalarWhereWithAggregatesInput!]
  NOT: [ActorScalarWhereWithAggregatesInput!]
  OR: [ActorScalarWhereWithAggregatesInput!]
  actor_id: IntWithAggregatesFilter
  first_name: StringWithAggregatesFilter
  last_name: StringWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
}

type ActorSumAggregate {
  actor_id: Int
}

input ActorSumOrderByAggregateInput {
  actor_id: SortOrder
}

input ActorUpdateInput {
  film_actor: Film_actorUpdateManyWithoutActorNestedInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input ActorUpdateManyMutationInput {
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input ActorUpdateOneRequiredWithoutFilm_actorNestedInput {
  connect: ActorWhereUniqueInput
  connectOrCreate: ActorCreateOrConnectWithoutFilm_actorInput
  create: ActorCreateWithoutFilm_actorInput
  update: ActorUpdateToOneWithWhereWithoutFilm_actorInput
  upsert: ActorUpsertWithoutFilm_actorInput
}

input ActorUpdateToOneWithWhereWithoutFilm_actorInput {
  data: ActorUpdateWithoutFilm_actorInput!
  where: ActorWhereInput
}

input ActorUpdateWithoutFilm_actorInput {
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input ActorUpsertWithoutFilm_actorInput {
  create: ActorCreateWithoutFilm_actorInput!
  update: ActorUpdateWithoutFilm_actorInput!
  where: ActorWhereInput
}

input ActorWhereInput {
  AND: [ActorWhereInput!]
  NOT: [ActorWhereInput!]
  OR: [ActorWhereInput!]
  actor_id: IntFilter
  film_actor: Film_actorListRelationFilter
  first_name: StringFilter
  last_name: StringFilter
  last_update: DateTimeFilter
}

input ActorWhereUniqueInput {
  AND: [ActorWhereInput!]
  NOT: [ActorWhereInput!]
  OR: [ActorWhereInput!]
  actor_id: Int
  film_actor: Film_actorListRelationFilter
  first_name: StringFilter
  last_name: StringFilter
  last_update: DateTimeFilter
}

type Address {
  _count: AddressCount
  address: String!
  address2: String
  address_id: Int!
  city: City!
  city_id: Int!
  customer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  district: String!
  last_update: DateTimeISO!
  phone: String!
  postal_code: String
  staff(cursor: StaffWhereUniqueInput, distinct: [StaffScalarFieldEnum!], orderBy: [StaffOrderByWithRelationInput!], skip: Int, take: Int, where: StaffWhereInput): [Staff!]!
  store(cursor: StoreWhereUniqueInput, distinct: [StoreScalarFieldEnum!], orderBy: [StoreOrderByWithRelationInput!], skip: Int, take: Int, where: StoreWhereInput): [Store!]!
}

type AddressAvgAggregate {
  address_id: Float
  city_id: Float
}

input AddressAvgOrderByAggregateInput {
  address_id: SortOrder
  city_id: SortOrder
}

type AddressCount {
  customer(where: CustomerWhereInput): Int!
  staff(where: StaffWhereInput): Int!
  store(where: StoreWhereInput): Int!
}

type AddressCountAggregate {
  _all: Int!
  address: Int!
  address2: Int!
  address_id: Int!
  city_id: Int!
  district: Int!
  last_update: Int!
  phone: Int!
  postal_code: Int!
}

input AddressCountOrderByAggregateInput {
  address: SortOrder
  address2: SortOrder
  address_id: SortOrder
  city_id: SortOrder
  district: SortOrder
  last_update: SortOrder
  phone: SortOrder
  postal_code: SortOrder
}

input AddressCreateNestedManyWithoutCityInput {
  connect: [AddressWhereUniqueInput!]
}

input AddressCreateNestedOneWithoutCustomerInput {
  connect: AddressWhereUniqueInput
}

input AddressCreateNestedOneWithoutStaffInput {
  connect: AddressWhereUniqueInput
}

input AddressCreateNestedOneWithoutStoreInput {
  connect: AddressWhereUniqueInput
}

type AddressGroupBy {
  _avg: AddressAvgAggregate
  _count: AddressCountAggregate
  _max: AddressMaxAggregate
  _min: AddressMinAggregate
  _sum: AddressSumAggregate
  address: String!
  address2: String
  address_id: Int!
  city_id: Int!
  district: String!
  last_update: DateTimeISO!
  phone: String!
  postal_code: String
}

input AddressListRelationFilter {
  every: AddressWhereInput
  none: AddressWhereInput
  some: AddressWhereInput
}

type AddressMaxAggregate {
  address: String
  address2: String
  address_id: Int
  city_id: Int
  district: String
  last_update: DateTimeISO
  phone: String
  postal_code: String
}

input AddressMaxOrderByAggregateInput {
  address: SortOrder
  address2: SortOrder
  address_id: SortOrder
  city_id: SortOrder
  district: SortOrder
  last_update: SortOrder
  phone: SortOrder
  postal_code: SortOrder
}

type AddressMinAggregate {
  address: String
  address2: String
  address_id: Int
  city_id: Int
  district: String
  last_update: DateTimeISO
  phone: String
  postal_code: String
}

input AddressMinOrderByAggregateInput {
  address: SortOrder
  address2: SortOrder
  address_id: SortOrder
  city_id: SortOrder
  district: SortOrder
  last_update: SortOrder
  phone: SortOrder
  postal_code: SortOrder
}

input AddressOrderByRelationAggregateInput {
  _count: SortOrder
}

input AddressOrderByWithAggregationInput {
  _avg: AddressAvgOrderByAggregateInput
  _count: AddressCountOrderByAggregateInput
  _max: AddressMaxOrderByAggregateInput
  _min: AddressMinOrderByAggregateInput
  _sum: AddressSumOrderByAggregateInput
  address: SortOrder
  address2: SortOrderInput
  address_id: SortOrder
  city_id: SortOrder
  district: SortOrder
  last_update: SortOrder
  phone: SortOrder
  postal_code: SortOrderInput
}

input AddressOrderByWithRelationInput {
  address: SortOrder
  address2: SortOrderInput
  address_id: SortOrder
  city: CityOrderByWithRelationInput
  city_id: SortOrder
  customer: CustomerOrderByRelationAggregateInput
  district: SortOrder
  last_update: SortOrder
  phone: SortOrder
  postal_code: SortOrderInput
  staff: StaffOrderByRelationAggregateInput
  store: StoreOrderByRelationAggregateInput
}

input AddressRelationFilter {
  is: AddressWhereInput
  isNot: AddressWhereInput
}

enum AddressScalarFieldEnum {
  address
  address2
  address_id
  city_id
  district
  last_update
  phone
  postal_code
}

input AddressScalarWhereInput {
  AND: [AddressScalarWhereInput!]
  NOT: [AddressScalarWhereInput!]
  OR: [AddressScalarWhereInput!]
  address: StringFilter
  address2: StringNullableFilter
  address_id: IntFilter
  city_id: IntFilter
  district: StringFilter
  last_update: DateTimeFilter
  phone: StringFilter
  postal_code: StringNullableFilter
}

input AddressScalarWhereWithAggregatesInput {
  AND: [AddressScalarWhereWithAggregatesInput!]
  NOT: [AddressScalarWhereWithAggregatesInput!]
  OR: [AddressScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  address2: StringNullableWithAggregatesFilter
  address_id: IntWithAggregatesFilter
  city_id: IntWithAggregatesFilter
  district: StringWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
  phone: StringWithAggregatesFilter
  postal_code: StringNullableWithAggregatesFilter
}

type AddressSumAggregate {
  address_id: Int
  city_id: Int
}

input AddressSumOrderByAggregateInput {
  address_id: SortOrder
  city_id: SortOrder
}

input AddressUpdateInput {
  address: StringFieldUpdateOperationsInput
  address2: NullableStringFieldUpdateOperationsInput
  city: CityUpdateOneRequiredWithoutAddressNestedInput
  customer: CustomerUpdateManyWithoutAddressNestedInput
  district: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  postal_code: NullableStringFieldUpdateOperationsInput
  staff: StaffUpdateManyWithoutAddressNestedInput
  store: StoreUpdateManyWithoutAddressNestedInput
}

input AddressUpdateManyMutationInput {
  address: StringFieldUpdateOperationsInput
  address2: NullableStringFieldUpdateOperationsInput
  district: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  postal_code: NullableStringFieldUpdateOperationsInput
}

input AddressUpdateManyWithWhereWithoutCityInput {
  data: AddressUpdateManyMutationInput!
  where: AddressScalarWhereInput!
}

input AddressUpdateManyWithoutCityNestedInput {
  connect: [AddressWhereUniqueInput!]
  delete: [AddressWhereUniqueInput!]
  deleteMany: [AddressScalarWhereInput!]
  disconnect: [AddressWhereUniqueInput!]
  set: [AddressWhereUniqueInput!]
  update: [AddressUpdateWithWhereUniqueWithoutCityInput!]
  updateMany: [AddressUpdateManyWithWhereWithoutCityInput!]
}

input AddressUpdateOneRequiredWithoutCustomerNestedInput {
  connect: AddressWhereUniqueInput
  update: AddressUpdateToOneWithWhereWithoutCustomerInput
}

input AddressUpdateOneRequiredWithoutStaffNestedInput {
  connect: AddressWhereUniqueInput
  update: AddressUpdateToOneWithWhereWithoutStaffInput
}

input AddressUpdateOneRequiredWithoutStoreNestedInput {
  connect: AddressWhereUniqueInput
  update: AddressUpdateToOneWithWhereWithoutStoreInput
}

input AddressUpdateToOneWithWhereWithoutCustomerInput {
  data: AddressUpdateWithoutCustomerInput!
  where: AddressWhereInput
}

input AddressUpdateToOneWithWhereWithoutStaffInput {
  data: AddressUpdateWithoutStaffInput!
  where: AddressWhereInput
}

input AddressUpdateToOneWithWhereWithoutStoreInput {
  data: AddressUpdateWithoutStoreInput!
  where: AddressWhereInput
}

input AddressUpdateWithWhereUniqueWithoutCityInput {
  data: AddressUpdateWithoutCityInput!
  where: AddressWhereUniqueInput!
}

input AddressUpdateWithoutCityInput {
  address: StringFieldUpdateOperationsInput
  address2: NullableStringFieldUpdateOperationsInput
  customer: CustomerUpdateManyWithoutAddressNestedInput
  district: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  postal_code: NullableStringFieldUpdateOperationsInput
  staff: StaffUpdateManyWithoutAddressNestedInput
  store: StoreUpdateManyWithoutAddressNestedInput
}

input AddressUpdateWithoutCustomerInput {
  address: StringFieldUpdateOperationsInput
  address2: NullableStringFieldUpdateOperationsInput
  city: CityUpdateOneRequiredWithoutAddressNestedInput
  district: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  postal_code: NullableStringFieldUpdateOperationsInput
  staff: StaffUpdateManyWithoutAddressNestedInput
  store: StoreUpdateManyWithoutAddressNestedInput
}

input AddressUpdateWithoutStaffInput {
  address: StringFieldUpdateOperationsInput
  address2: NullableStringFieldUpdateOperationsInput
  city: CityUpdateOneRequiredWithoutAddressNestedInput
  customer: CustomerUpdateManyWithoutAddressNestedInput
  district: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  postal_code: NullableStringFieldUpdateOperationsInput
  store: StoreUpdateManyWithoutAddressNestedInput
}

input AddressUpdateWithoutStoreInput {
  address: StringFieldUpdateOperationsInput
  address2: NullableStringFieldUpdateOperationsInput
  city: CityUpdateOneRequiredWithoutAddressNestedInput
  customer: CustomerUpdateManyWithoutAddressNestedInput
  district: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  postal_code: NullableStringFieldUpdateOperationsInput
  staff: StaffUpdateManyWithoutAddressNestedInput
}

input AddressWhereInput {
  AND: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  address: StringFilter
  address2: StringNullableFilter
  address_id: IntFilter
  city: CityRelationFilter
  city_id: IntFilter
  customer: CustomerListRelationFilter
  district: StringFilter
  last_update: DateTimeFilter
  phone: StringFilter
  postal_code: StringNullableFilter
  staff: StaffListRelationFilter
  store: StoreListRelationFilter
}

input AddressWhereUniqueInput {
  AND: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  address: StringFilter
  address2: StringNullableFilter
  address_id: Int
  city: CityRelationFilter
  city_id: IntFilter
  customer: CustomerListRelationFilter
  district: StringFilter
  last_update: DateTimeFilter
  phone: StringFilter
  postal_code: StringNullableFilter
  staff: StaffListRelationFilter
  store: StoreListRelationFilter
}

type AffectedRowsOutput {
  count: Int!
}

type AggregateActor {
  _avg: ActorAvgAggregate
  _count: ActorCountAggregate
  _max: ActorMaxAggregate
  _min: ActorMinAggregate
  _sum: ActorSumAggregate
}

type AggregateAddress {
  _avg: AddressAvgAggregate
  _count: AddressCountAggregate
  _max: AddressMaxAggregate
  _min: AddressMinAggregate
  _sum: AddressSumAggregate
}

type AggregateCategory {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
}

type AggregateCity {
  _avg: CityAvgAggregate
  _count: CityCountAggregate
  _max: CityMaxAggregate
  _min: CityMinAggregate
  _sum: CitySumAggregate
}

type AggregateCountry {
  _avg: CountryAvgAggregate
  _count: CountryCountAggregate
  _max: CountryMaxAggregate
  _min: CountryMinAggregate
  _sum: CountrySumAggregate
}

type AggregateCustomer {
  _avg: CustomerAvgAggregate
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  _sum: CustomerSumAggregate
}

type AggregateFilm {
  _avg: FilmAvgAggregate
  _count: FilmCountAggregate
  _max: FilmMaxAggregate
  _min: FilmMinAggregate
  _sum: FilmSumAggregate
}

type AggregateFilm_actor {
  _avg: Film_actorAvgAggregate
  _count: Film_actorCountAggregate
  _max: Film_actorMaxAggregate
  _min: Film_actorMinAggregate
  _sum: Film_actorSumAggregate
}

type AggregateFilm_category {
  _avg: Film_categoryAvgAggregate
  _count: Film_categoryCountAggregate
  _max: Film_categoryMaxAggregate
  _min: Film_categoryMinAggregate
  _sum: Film_categorySumAggregate
}

type AggregateFilm_text {
  _avg: Film_textAvgAggregate
  _count: Film_textCountAggregate
  _max: Film_textMaxAggregate
  _min: Film_textMinAggregate
  _sum: Film_textSumAggregate
}

type AggregateInventory {
  _avg: InventoryAvgAggregate
  _count: InventoryCountAggregate
  _max: InventoryMaxAggregate
  _min: InventoryMinAggregate
  _sum: InventorySumAggregate
}

type AggregateLanguage {
  _avg: LanguageAvgAggregate
  _count: LanguageCountAggregate
  _max: LanguageMaxAggregate
  _min: LanguageMinAggregate
  _sum: LanguageSumAggregate
}

type AggregatePayment {
  _avg: PaymentAvgAggregate
  _count: PaymentCountAggregate
  _max: PaymentMaxAggregate
  _min: PaymentMinAggregate
  _sum: PaymentSumAggregate
}

type AggregateRental {
  _avg: RentalAvgAggregate
  _count: RentalCountAggregate
  _max: RentalMaxAggregate
  _min: RentalMinAggregate
  _sum: RentalSumAggregate
}

type AggregateStaff {
  _avg: StaffAvgAggregate
  _count: StaffCountAggregate
  _max: StaffMaxAggregate
  _min: StaffMinAggregate
  _sum: StaffSumAggregate
}

type AggregateStore {
  _avg: StoreAvgAggregate
  _count: StoreCountAggregate
  _max: StoreMaxAggregate
  _min: StoreMinAggregate
  _sum: StoreSumAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

"""The `Byte` scalar type represents byte value as a Buffer"""
scalar Byte

input BytesNullableFilter {
  equals: Byte
  in: [Byte!]
  not: NestedBytesNullableFilter
  notIn: [Byte!]
}

input BytesNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBytesNullableFilter
  _min: NestedBytesNullableFilter
  equals: Byte
  in: [Byte!]
  not: NestedBytesNullableWithAggregatesFilter
  notIn: [Byte!]
}

type Category {
  _count: CategoryCount
  category_id: Int!
  film_category(cursor: Film_categoryWhereUniqueInput, distinct: [Film_categoryScalarFieldEnum!], orderBy: [Film_categoryOrderByWithRelationInput!], skip: Int, take: Int, where: Film_categoryWhereInput): [Film_category!]!
  last_update: DateTimeISO!
  name: String!
}

type CategoryAvgAggregate {
  category_id: Float
}

input CategoryAvgOrderByAggregateInput {
  category_id: SortOrder
}

type CategoryCount {
  film_category(where: Film_categoryWhereInput): Int!
}

type CategoryCountAggregate {
  _all: Int!
  category_id: Int!
  last_update: Int!
  name: Int!
}

input CategoryCountOrderByAggregateInput {
  category_id: SortOrder
  last_update: SortOrder
  name: SortOrder
}

input CategoryCreateInput {
  film_category: Film_categoryCreateNestedManyWithoutCategoryInput
  last_update: DateTimeISO
  name: String!
}

input CategoryCreateManyInput {
  category_id: Int
  last_update: DateTimeISO
  name: String!
}

input CategoryCreateNestedOneWithoutFilm_categoryInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutFilm_categoryInput
  create: CategoryCreateWithoutFilm_categoryInput
}

input CategoryCreateOrConnectWithoutFilm_categoryInput {
  create: CategoryCreateWithoutFilm_categoryInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateWithoutFilm_categoryInput {
  last_update: DateTimeISO
  name: String!
}

type CategoryGroupBy {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
  category_id: Int!
  last_update: DateTimeISO!
  name: String!
}

type CategoryMaxAggregate {
  category_id: Int
  last_update: DateTimeISO
  name: String
}

input CategoryMaxOrderByAggregateInput {
  category_id: SortOrder
  last_update: SortOrder
  name: SortOrder
}

type CategoryMinAggregate {
  category_id: Int
  last_update: DateTimeISO
  name: String
}

input CategoryMinOrderByAggregateInput {
  category_id: SortOrder
  last_update: SortOrder
  name: SortOrder
}

input CategoryOrderByWithAggregationInput {
  _avg: CategoryAvgOrderByAggregateInput
  _count: CategoryCountOrderByAggregateInput
  _max: CategoryMaxOrderByAggregateInput
  _min: CategoryMinOrderByAggregateInput
  _sum: CategorySumOrderByAggregateInput
  category_id: SortOrder
  last_update: SortOrder
  name: SortOrder
}

input CategoryOrderByWithRelationInput {
  category_id: SortOrder
  film_category: Film_categoryOrderByRelationAggregateInput
  last_update: SortOrder
  name: SortOrder
}

input CategoryRelationFilter {
  is: CategoryWhereInput
  isNot: CategoryWhereInput
}

enum CategoryScalarFieldEnum {
  category_id
  last_update
  name
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput!]
  NOT: [CategoryScalarWhereWithAggregatesInput!]
  OR: [CategoryScalarWhereWithAggregatesInput!]
  category_id: IntWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type CategorySumAggregate {
  category_id: Int
}

input CategorySumOrderByAggregateInput {
  category_id: SortOrder
}

input CategoryUpdateInput {
  film_category: Film_categoryUpdateManyWithoutCategoryNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CategoryUpdateManyMutationInput {
  last_update: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CategoryUpdateOneRequiredWithoutFilm_categoryNestedInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutFilm_categoryInput
  create: CategoryCreateWithoutFilm_categoryInput
  update: CategoryUpdateToOneWithWhereWithoutFilm_categoryInput
  upsert: CategoryUpsertWithoutFilm_categoryInput
}

input CategoryUpdateToOneWithWhereWithoutFilm_categoryInput {
  data: CategoryUpdateWithoutFilm_categoryInput!
  where: CategoryWhereInput
}

input CategoryUpdateWithoutFilm_categoryInput {
  last_update: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CategoryUpsertWithoutFilm_categoryInput {
  create: CategoryCreateWithoutFilm_categoryInput!
  update: CategoryUpdateWithoutFilm_categoryInput!
  where: CategoryWhereInput
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  category_id: IntFilter
  film_category: Film_categoryListRelationFilter
  last_update: DateTimeFilter
  name: StringFilter
}

input CategoryWhereUniqueInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  category_id: Int
  film_category: Film_categoryListRelationFilter
  last_update: DateTimeFilter
  name: StringFilter
}

type City {
  _count: CityCount
  address(cursor: AddressWhereUniqueInput, distinct: [AddressScalarFieldEnum!], orderBy: [AddressOrderByWithRelationInput!], skip: Int, take: Int, where: AddressWhereInput): [Address!]!
  city: String!
  city_id: Int!
  country: Country!
  country_id: Int!
  last_update: DateTimeISO!
}

type CityAvgAggregate {
  city_id: Float
  country_id: Float
}

input CityAvgOrderByAggregateInput {
  city_id: SortOrder
  country_id: SortOrder
}

type CityCount {
  address(where: AddressWhereInput): Int!
}

type CityCountAggregate {
  _all: Int!
  city: Int!
  city_id: Int!
  country_id: Int!
  last_update: Int!
}

input CityCountOrderByAggregateInput {
  city: SortOrder
  city_id: SortOrder
  country_id: SortOrder
  last_update: SortOrder
}

input CityCreateInput {
  address: AddressCreateNestedManyWithoutCityInput
  city: String!
  country: CountryCreateNestedOneWithoutCityInput!
  last_update: DateTimeISO
}

input CityCreateManyCountryInput {
  city: String!
  city_id: Int
  last_update: DateTimeISO
}

input CityCreateManyCountryInputEnvelope {
  data: [CityCreateManyCountryInput!]!
  skipDuplicates: Boolean
}

input CityCreateManyInput {
  city: String!
  city_id: Int
  country_id: Int!
  last_update: DateTimeISO
}

input CityCreateNestedManyWithoutCountryInput {
  connect: [CityWhereUniqueInput!]
  connectOrCreate: [CityCreateOrConnectWithoutCountryInput!]
  create: [CityCreateWithoutCountryInput!]
  createMany: CityCreateManyCountryInputEnvelope
}

input CityCreateOrConnectWithoutAddressInput {
  create: CityCreateWithoutAddressInput!
  where: CityWhereUniqueInput!
}

input CityCreateOrConnectWithoutCountryInput {
  create: CityCreateWithoutCountryInput!
  where: CityWhereUniqueInput!
}

input CityCreateWithoutAddressInput {
  city: String!
  country: CountryCreateNestedOneWithoutCityInput!
  last_update: DateTimeISO
}

input CityCreateWithoutCountryInput {
  address: AddressCreateNestedManyWithoutCityInput
  city: String!
  last_update: DateTimeISO
}

type CityGroupBy {
  _avg: CityAvgAggregate
  _count: CityCountAggregate
  _max: CityMaxAggregate
  _min: CityMinAggregate
  _sum: CitySumAggregate
  city: String!
  city_id: Int!
  country_id: Int!
  last_update: DateTimeISO!
}

input CityListRelationFilter {
  every: CityWhereInput
  none: CityWhereInput
  some: CityWhereInput
}

type CityMaxAggregate {
  city: String
  city_id: Int
  country_id: Int
  last_update: DateTimeISO
}

input CityMaxOrderByAggregateInput {
  city: SortOrder
  city_id: SortOrder
  country_id: SortOrder
  last_update: SortOrder
}

type CityMinAggregate {
  city: String
  city_id: Int
  country_id: Int
  last_update: DateTimeISO
}

input CityMinOrderByAggregateInput {
  city: SortOrder
  city_id: SortOrder
  country_id: SortOrder
  last_update: SortOrder
}

input CityOrderByRelationAggregateInput {
  _count: SortOrder
}

input CityOrderByWithAggregationInput {
  _avg: CityAvgOrderByAggregateInput
  _count: CityCountOrderByAggregateInput
  _max: CityMaxOrderByAggregateInput
  _min: CityMinOrderByAggregateInput
  _sum: CitySumOrderByAggregateInput
  city: SortOrder
  city_id: SortOrder
  country_id: SortOrder
  last_update: SortOrder
}

input CityOrderByWithRelationInput {
  address: AddressOrderByRelationAggregateInput
  city: SortOrder
  city_id: SortOrder
  country: CountryOrderByWithRelationInput
  country_id: SortOrder
  last_update: SortOrder
}

input CityRelationFilter {
  is: CityWhereInput
  isNot: CityWhereInput
}

enum CityScalarFieldEnum {
  city
  city_id
  country_id
  last_update
}

input CityScalarWhereInput {
  AND: [CityScalarWhereInput!]
  NOT: [CityScalarWhereInput!]
  OR: [CityScalarWhereInput!]
  city: StringFilter
  city_id: IntFilter
  country_id: IntFilter
  last_update: DateTimeFilter
}

input CityScalarWhereWithAggregatesInput {
  AND: [CityScalarWhereWithAggregatesInput!]
  NOT: [CityScalarWhereWithAggregatesInput!]
  OR: [CityScalarWhereWithAggregatesInput!]
  city: StringWithAggregatesFilter
  city_id: IntWithAggregatesFilter
  country_id: IntWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
}

type CitySumAggregate {
  city_id: Int
  country_id: Int
}

input CitySumOrderByAggregateInput {
  city_id: SortOrder
  country_id: SortOrder
}

input CityUpdateInput {
  address: AddressUpdateManyWithoutCityNestedInput
  city: StringFieldUpdateOperationsInput
  country: CountryUpdateOneRequiredWithoutCityNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input CityUpdateManyMutationInput {
  city: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input CityUpdateManyWithWhereWithoutCountryInput {
  data: CityUpdateManyMutationInput!
  where: CityScalarWhereInput!
}

input CityUpdateManyWithoutCountryNestedInput {
  connect: [CityWhereUniqueInput!]
  connectOrCreate: [CityCreateOrConnectWithoutCountryInput!]
  create: [CityCreateWithoutCountryInput!]
  createMany: CityCreateManyCountryInputEnvelope
  delete: [CityWhereUniqueInput!]
  deleteMany: [CityScalarWhereInput!]
  disconnect: [CityWhereUniqueInput!]
  set: [CityWhereUniqueInput!]
  update: [CityUpdateWithWhereUniqueWithoutCountryInput!]
  updateMany: [CityUpdateManyWithWhereWithoutCountryInput!]
  upsert: [CityUpsertWithWhereUniqueWithoutCountryInput!]
}

input CityUpdateOneRequiredWithoutAddressNestedInput {
  connect: CityWhereUniqueInput
  connectOrCreate: CityCreateOrConnectWithoutAddressInput
  create: CityCreateWithoutAddressInput
  update: CityUpdateToOneWithWhereWithoutAddressInput
  upsert: CityUpsertWithoutAddressInput
}

input CityUpdateToOneWithWhereWithoutAddressInput {
  data: CityUpdateWithoutAddressInput!
  where: CityWhereInput
}

input CityUpdateWithWhereUniqueWithoutCountryInput {
  data: CityUpdateWithoutCountryInput!
  where: CityWhereUniqueInput!
}

input CityUpdateWithoutAddressInput {
  city: StringFieldUpdateOperationsInput
  country: CountryUpdateOneRequiredWithoutCityNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input CityUpdateWithoutCountryInput {
  address: AddressUpdateManyWithoutCityNestedInput
  city: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input CityUpsertWithWhereUniqueWithoutCountryInput {
  create: CityCreateWithoutCountryInput!
  update: CityUpdateWithoutCountryInput!
  where: CityWhereUniqueInput!
}

input CityUpsertWithoutAddressInput {
  create: CityCreateWithoutAddressInput!
  update: CityUpdateWithoutAddressInput!
  where: CityWhereInput
}

input CityWhereInput {
  AND: [CityWhereInput!]
  NOT: [CityWhereInput!]
  OR: [CityWhereInput!]
  address: AddressListRelationFilter
  city: StringFilter
  city_id: IntFilter
  country: CountryRelationFilter
  country_id: IntFilter
  last_update: DateTimeFilter
}

input CityWhereUniqueInput {
  AND: [CityWhereInput!]
  NOT: [CityWhereInput!]
  OR: [CityWhereInput!]
  address: AddressListRelationFilter
  city: StringFilter
  city_id: Int
  country: CountryRelationFilter
  country_id: IntFilter
  last_update: DateTimeFilter
}

type Country {
  _count: CountryCount
  city(cursor: CityWhereUniqueInput, distinct: [CityScalarFieldEnum!], orderBy: [CityOrderByWithRelationInput!], skip: Int, take: Int, where: CityWhereInput): [City!]!
  country: String!
  country_id: Int!
  last_update: DateTimeISO!
}

type CountryAvgAggregate {
  country_id: Float
}

input CountryAvgOrderByAggregateInput {
  country_id: SortOrder
}

type CountryCount {
  city(where: CityWhereInput): Int!
}

type CountryCountAggregate {
  _all: Int!
  country: Int!
  country_id: Int!
  last_update: Int!
}

input CountryCountOrderByAggregateInput {
  country: SortOrder
  country_id: SortOrder
  last_update: SortOrder
}

input CountryCreateInput {
  city: CityCreateNestedManyWithoutCountryInput
  country: String!
  last_update: DateTimeISO
}

input CountryCreateManyInput {
  country: String!
  country_id: Int
  last_update: DateTimeISO
}

input CountryCreateNestedOneWithoutCityInput {
  connect: CountryWhereUniqueInput
  connectOrCreate: CountryCreateOrConnectWithoutCityInput
  create: CountryCreateWithoutCityInput
}

input CountryCreateOrConnectWithoutCityInput {
  create: CountryCreateWithoutCityInput!
  where: CountryWhereUniqueInput!
}

input CountryCreateWithoutCityInput {
  country: String!
  last_update: DateTimeISO
}

type CountryGroupBy {
  _avg: CountryAvgAggregate
  _count: CountryCountAggregate
  _max: CountryMaxAggregate
  _min: CountryMinAggregate
  _sum: CountrySumAggregate
  country: String!
  country_id: Int!
  last_update: DateTimeISO!
}

type CountryMaxAggregate {
  country: String
  country_id: Int
  last_update: DateTimeISO
}

input CountryMaxOrderByAggregateInput {
  country: SortOrder
  country_id: SortOrder
  last_update: SortOrder
}

type CountryMinAggregate {
  country: String
  country_id: Int
  last_update: DateTimeISO
}

input CountryMinOrderByAggregateInput {
  country: SortOrder
  country_id: SortOrder
  last_update: SortOrder
}

input CountryOrderByWithAggregationInput {
  _avg: CountryAvgOrderByAggregateInput
  _count: CountryCountOrderByAggregateInput
  _max: CountryMaxOrderByAggregateInput
  _min: CountryMinOrderByAggregateInput
  _sum: CountrySumOrderByAggregateInput
  country: SortOrder
  country_id: SortOrder
  last_update: SortOrder
}

input CountryOrderByWithRelationInput {
  city: CityOrderByRelationAggregateInput
  country: SortOrder
  country_id: SortOrder
  last_update: SortOrder
}

input CountryRelationFilter {
  is: CountryWhereInput
  isNot: CountryWhereInput
}

enum CountryScalarFieldEnum {
  country
  country_id
  last_update
}

input CountryScalarWhereWithAggregatesInput {
  AND: [CountryScalarWhereWithAggregatesInput!]
  NOT: [CountryScalarWhereWithAggregatesInput!]
  OR: [CountryScalarWhereWithAggregatesInput!]
  country: StringWithAggregatesFilter
  country_id: IntWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
}

type CountrySumAggregate {
  country_id: Int
}

input CountrySumOrderByAggregateInput {
  country_id: SortOrder
}

input CountryUpdateInput {
  city: CityUpdateManyWithoutCountryNestedInput
  country: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input CountryUpdateManyMutationInput {
  country: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input CountryUpdateOneRequiredWithoutCityNestedInput {
  connect: CountryWhereUniqueInput
  connectOrCreate: CountryCreateOrConnectWithoutCityInput
  create: CountryCreateWithoutCityInput
  update: CountryUpdateToOneWithWhereWithoutCityInput
  upsert: CountryUpsertWithoutCityInput
}

input CountryUpdateToOneWithWhereWithoutCityInput {
  data: CountryUpdateWithoutCityInput!
  where: CountryWhereInput
}

input CountryUpdateWithoutCityInput {
  country: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input CountryUpsertWithoutCityInput {
  create: CountryCreateWithoutCityInput!
  update: CountryUpdateWithoutCityInput!
  where: CountryWhereInput
}

input CountryWhereInput {
  AND: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  city: CityListRelationFilter
  country: StringFilter
  country_id: IntFilter
  last_update: DateTimeFilter
}

input CountryWhereUniqueInput {
  AND: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  city: CityListRelationFilter
  country: StringFilter
  country_id: Int
  last_update: DateTimeFilter
}

type Customer {
  _count: CustomerCount
  active: Boolean!
  address: Address!
  address_id: Int!
  create_date: DateTimeISO!
  customer_id: Int!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  payment(cursor: PaymentWhereUniqueInput, distinct: [PaymentScalarFieldEnum!], orderBy: [PaymentOrderByWithRelationInput!], skip: Int, take: Int, where: PaymentWhereInput): [Payment!]!
  rental(cursor: RentalWhereUniqueInput, distinct: [RentalScalarFieldEnum!], orderBy: [RentalOrderByWithRelationInput!], skip: Int, take: Int, where: RentalWhereInput): [Rental!]!
  store: Store!
  store_id: Int!
}

type CustomerAvgAggregate {
  address_id: Float
  customer_id: Float
  store_id: Float
}

input CustomerAvgOrderByAggregateInput {
  address_id: SortOrder
  customer_id: SortOrder
  store_id: SortOrder
}

type CustomerCount {
  payment(where: PaymentWhereInput): Int!
  rental(where: RentalWhereInput): Int!
}

type CustomerCountAggregate {
  _all: Int!
  active: Int!
  address_id: Int!
  create_date: Int!
  customer_id: Int!
  email: Int!
  first_name: Int!
  last_name: Int!
  last_update: Int!
  store_id: Int!
}

input CustomerCountOrderByAggregateInput {
  active: SortOrder
  address_id: SortOrder
  create_date: SortOrder
  customer_id: SortOrder
  email: SortOrder
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
  store_id: SortOrder
}

input CustomerCreateInput {
  active: Boolean
  address: AddressCreateNestedOneWithoutCustomerInput!
  create_date: DateTimeISO!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  payment: PaymentCreateNestedManyWithoutCustomerInput
  rental: RentalCreateNestedManyWithoutCustomerInput
  store: StoreCreateNestedOneWithoutCustomerInput!
}

input CustomerCreateManyAddressInput {
  active: Boolean
  create_date: DateTimeISO!
  customer_id: Int
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  store_id: Int!
}

input CustomerCreateManyAddressInputEnvelope {
  data: [CustomerCreateManyAddressInput!]!
  skipDuplicates: Boolean
}

input CustomerCreateManyInput {
  active: Boolean
  address_id: Int!
  create_date: DateTimeISO!
  customer_id: Int
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  store_id: Int!
}

input CustomerCreateManyStoreInput {
  active: Boolean
  address_id: Int!
  create_date: DateTimeISO!
  customer_id: Int
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
}

input CustomerCreateManyStoreInputEnvelope {
  data: [CustomerCreateManyStoreInput!]!
  skipDuplicates: Boolean
}

input CustomerCreateNestedManyWithoutStoreInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutStoreInput!]
  create: [CustomerCreateWithoutStoreInput!]
  createMany: CustomerCreateManyStoreInputEnvelope
}

input CustomerCreateNestedOneWithoutPaymentInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutPaymentInput
  create: CustomerCreateWithoutPaymentInput
}

input CustomerCreateNestedOneWithoutRentalInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutRentalInput
  create: CustomerCreateWithoutRentalInput
}

input CustomerCreateOrConnectWithoutAddressInput {
  create: CustomerCreateWithoutAddressInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateOrConnectWithoutPaymentInput {
  create: CustomerCreateWithoutPaymentInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateOrConnectWithoutRentalInput {
  create: CustomerCreateWithoutRentalInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateOrConnectWithoutStoreInput {
  create: CustomerCreateWithoutStoreInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateWithoutAddressInput {
  active: Boolean
  create_date: DateTimeISO!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  payment: PaymentCreateNestedManyWithoutCustomerInput
  rental: RentalCreateNestedManyWithoutCustomerInput
  store: StoreCreateNestedOneWithoutCustomerInput!
}

input CustomerCreateWithoutPaymentInput {
  active: Boolean
  address: AddressCreateNestedOneWithoutCustomerInput!
  create_date: DateTimeISO!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  rental: RentalCreateNestedManyWithoutCustomerInput
  store: StoreCreateNestedOneWithoutCustomerInput!
}

input CustomerCreateWithoutRentalInput {
  active: Boolean
  address: AddressCreateNestedOneWithoutCustomerInput!
  create_date: DateTimeISO!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  payment: PaymentCreateNestedManyWithoutCustomerInput
  store: StoreCreateNestedOneWithoutCustomerInput!
}

input CustomerCreateWithoutStoreInput {
  active: Boolean
  address: AddressCreateNestedOneWithoutCustomerInput!
  create_date: DateTimeISO!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  payment: PaymentCreateNestedManyWithoutCustomerInput
  rental: RentalCreateNestedManyWithoutCustomerInput
}

type CustomerGroupBy {
  _avg: CustomerAvgAggregate
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  _sum: CustomerSumAggregate
  active: Boolean!
  address_id: Int!
  create_date: DateTimeISO!
  customer_id: Int!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  store_id: Int!
}

input CustomerListRelationFilter {
  every: CustomerWhereInput
  none: CustomerWhereInput
  some: CustomerWhereInput
}

type CustomerMaxAggregate {
  active: Boolean
  address_id: Int
  create_date: DateTimeISO
  customer_id: Int
  email: String
  first_name: String
  last_name: String
  last_update: DateTimeISO
  store_id: Int
}

input CustomerMaxOrderByAggregateInput {
  active: SortOrder
  address_id: SortOrder
  create_date: SortOrder
  customer_id: SortOrder
  email: SortOrder
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
  store_id: SortOrder
}

type CustomerMinAggregate {
  active: Boolean
  address_id: Int
  create_date: DateTimeISO
  customer_id: Int
  email: String
  first_name: String
  last_name: String
  last_update: DateTimeISO
  store_id: Int
}

input CustomerMinOrderByAggregateInput {
  active: SortOrder
  address_id: SortOrder
  create_date: SortOrder
  customer_id: SortOrder
  email: SortOrder
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
  store_id: SortOrder
}

input CustomerOrderByRelationAggregateInput {
  _count: SortOrder
}

input CustomerOrderByWithAggregationInput {
  _avg: CustomerAvgOrderByAggregateInput
  _count: CustomerCountOrderByAggregateInput
  _max: CustomerMaxOrderByAggregateInput
  _min: CustomerMinOrderByAggregateInput
  _sum: CustomerSumOrderByAggregateInput
  active: SortOrder
  address_id: SortOrder
  create_date: SortOrder
  customer_id: SortOrder
  email: SortOrderInput
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrderInput
  store_id: SortOrder
}

input CustomerOrderByWithRelationInput {
  active: SortOrder
  address: AddressOrderByWithRelationInput
  address_id: SortOrder
  create_date: SortOrder
  customer_id: SortOrder
  email: SortOrderInput
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrderInput
  payment: PaymentOrderByRelationAggregateInput
  rental: RentalOrderByRelationAggregateInput
  store: StoreOrderByWithRelationInput
  store_id: SortOrder
}

input CustomerRelationFilter {
  is: CustomerWhereInput
  isNot: CustomerWhereInput
}

enum CustomerScalarFieldEnum {
  active
  address_id
  create_date
  customer_id
  email
  first_name
  last_name
  last_update
  store_id
}

input CustomerScalarWhereInput {
  AND: [CustomerScalarWhereInput!]
  NOT: [CustomerScalarWhereInput!]
  OR: [CustomerScalarWhereInput!]
  active: BoolFilter
  address_id: IntFilter
  create_date: DateTimeFilter
  customer_id: IntFilter
  email: StringNullableFilter
  first_name: StringFilter
  last_name: StringFilter
  last_update: DateTimeNullableFilter
  store_id: IntFilter
}

input CustomerScalarWhereWithAggregatesInput {
  AND: [CustomerScalarWhereWithAggregatesInput!]
  NOT: [CustomerScalarWhereWithAggregatesInput!]
  OR: [CustomerScalarWhereWithAggregatesInput!]
  active: BoolWithAggregatesFilter
  address_id: IntWithAggregatesFilter
  create_date: DateTimeWithAggregatesFilter
  customer_id: IntWithAggregatesFilter
  email: StringNullableWithAggregatesFilter
  first_name: StringWithAggregatesFilter
  last_name: StringWithAggregatesFilter
  last_update: DateTimeNullableWithAggregatesFilter
  store_id: IntWithAggregatesFilter
}

type CustomerSumAggregate {
  address_id: Int
  customer_id: Int
  store_id: Int
}

input CustomerSumOrderByAggregateInput {
  address_id: SortOrder
  customer_id: SortOrder
  store_id: SortOrder
}

input CustomerUpdateInput {
  active: BoolFieldUpdateOperationsInput
  address: AddressUpdateOneRequiredWithoutCustomerNestedInput
  create_date: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: NullableDateTimeFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutCustomerNestedInput
  rental: RentalUpdateManyWithoutCustomerNestedInput
  store: StoreUpdateOneRequiredWithoutCustomerNestedInput
}

input CustomerUpdateManyMutationInput {
  active: BoolFieldUpdateOperationsInput
  create_date: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: NullableDateTimeFieldUpdateOperationsInput
}

input CustomerUpdateManyWithWhereWithoutAddressInput {
  data: CustomerUpdateManyMutationInput!
  where: CustomerScalarWhereInput!
}

input CustomerUpdateManyWithWhereWithoutStoreInput {
  data: CustomerUpdateManyMutationInput!
  where: CustomerScalarWhereInput!
}

input CustomerUpdateManyWithoutAddressNestedInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutAddressInput!]
  create: [CustomerCreateWithoutAddressInput!]
  createMany: CustomerCreateManyAddressInputEnvelope
  delete: [CustomerWhereUniqueInput!]
  deleteMany: [CustomerScalarWhereInput!]
  disconnect: [CustomerWhereUniqueInput!]
  set: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [CustomerUpdateManyWithWhereWithoutAddressInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutAddressInput!]
}

input CustomerUpdateManyWithoutStoreNestedInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutStoreInput!]
  create: [CustomerCreateWithoutStoreInput!]
  createMany: CustomerCreateManyStoreInputEnvelope
  delete: [CustomerWhereUniqueInput!]
  deleteMany: [CustomerScalarWhereInput!]
  disconnect: [CustomerWhereUniqueInput!]
  set: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutStoreInput!]
  updateMany: [CustomerUpdateManyWithWhereWithoutStoreInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutStoreInput!]
}

input CustomerUpdateOneRequiredWithoutPaymentNestedInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutPaymentInput
  create: CustomerCreateWithoutPaymentInput
  update: CustomerUpdateToOneWithWhereWithoutPaymentInput
  upsert: CustomerUpsertWithoutPaymentInput
}

input CustomerUpdateOneRequiredWithoutRentalNestedInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutRentalInput
  create: CustomerCreateWithoutRentalInput
  update: CustomerUpdateToOneWithWhereWithoutRentalInput
  upsert: CustomerUpsertWithoutRentalInput
}

input CustomerUpdateToOneWithWhereWithoutPaymentInput {
  data: CustomerUpdateWithoutPaymentInput!
  where: CustomerWhereInput
}

input CustomerUpdateToOneWithWhereWithoutRentalInput {
  data: CustomerUpdateWithoutRentalInput!
  where: CustomerWhereInput
}

input CustomerUpdateWithWhereUniqueWithoutAddressInput {
  data: CustomerUpdateWithoutAddressInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpdateWithWhereUniqueWithoutStoreInput {
  data: CustomerUpdateWithoutStoreInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpdateWithoutAddressInput {
  active: BoolFieldUpdateOperationsInput
  create_date: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: NullableDateTimeFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutCustomerNestedInput
  rental: RentalUpdateManyWithoutCustomerNestedInput
  store: StoreUpdateOneRequiredWithoutCustomerNestedInput
}

input CustomerUpdateWithoutPaymentInput {
  active: BoolFieldUpdateOperationsInput
  address: AddressUpdateOneRequiredWithoutCustomerNestedInput
  create_date: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: NullableDateTimeFieldUpdateOperationsInput
  rental: RentalUpdateManyWithoutCustomerNestedInput
  store: StoreUpdateOneRequiredWithoutCustomerNestedInput
}

input CustomerUpdateWithoutRentalInput {
  active: BoolFieldUpdateOperationsInput
  address: AddressUpdateOneRequiredWithoutCustomerNestedInput
  create_date: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: NullableDateTimeFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutCustomerNestedInput
  store: StoreUpdateOneRequiredWithoutCustomerNestedInput
}

input CustomerUpdateWithoutStoreInput {
  active: BoolFieldUpdateOperationsInput
  address: AddressUpdateOneRequiredWithoutCustomerNestedInput
  create_date: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: NullableDateTimeFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutCustomerNestedInput
  rental: RentalUpdateManyWithoutCustomerNestedInput
}

input CustomerUpsertWithWhereUniqueWithoutAddressInput {
  create: CustomerCreateWithoutAddressInput!
  update: CustomerUpdateWithoutAddressInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpsertWithWhereUniqueWithoutStoreInput {
  create: CustomerCreateWithoutStoreInput!
  update: CustomerUpdateWithoutStoreInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpsertWithoutPaymentInput {
  create: CustomerCreateWithoutPaymentInput!
  update: CustomerUpdateWithoutPaymentInput!
  where: CustomerWhereInput
}

input CustomerUpsertWithoutRentalInput {
  create: CustomerCreateWithoutRentalInput!
  update: CustomerUpdateWithoutRentalInput!
  where: CustomerWhereInput
}

input CustomerWhereInput {
  AND: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  active: BoolFilter
  address: AddressRelationFilter
  address_id: IntFilter
  create_date: DateTimeFilter
  customer_id: IntFilter
  email: StringNullableFilter
  first_name: StringFilter
  last_name: StringFilter
  last_update: DateTimeNullableFilter
  payment: PaymentListRelationFilter
  rental: RentalListRelationFilter
  store: StoreRelationFilter
  store_id: IntFilter
}

input CustomerWhereUniqueInput {
  AND: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  active: BoolFilter
  address: AddressRelationFilter
  address_id: IntFilter
  create_date: DateTimeFilter
  customer_id: Int
  email: StringNullableFilter
  first_name: StringFilter
  last_name: StringFilter
  last_update: DateTimeNullableFilter
  payment: PaymentListRelationFilter
  rental: RentalListRelationFilter
  store: StoreRelationFilter
  store_id: IntFilter
}

input DateTimeFieldUpdateOperationsInput {
  set: DateTimeISO
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

input DecimalFieldUpdateOperationsInput {
  decrement: Decimal
  divide: Decimal
  increment: Decimal
  multiply: Decimal
  set: Decimal
}

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input DecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

input Enumfilm_ratingNullableFilter {
  equals: film_rating
  in: [film_rating!]
  not: NestedEnumfilm_ratingNullableFilter
  notIn: [film_rating!]
}

input Enumfilm_ratingNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumfilm_ratingNullableFilter
  _min: NestedEnumfilm_ratingNullableFilter
  equals: film_rating
  in: [film_rating!]
  not: NestedEnumfilm_ratingNullableWithAggregatesFilter
  notIn: [film_rating!]
}

type Film {
  _count: FilmCount
  description: String
  film_actor(cursor: Film_actorWhereUniqueInput, distinct: [Film_actorScalarFieldEnum!], orderBy: [Film_actorOrderByWithRelationInput!], skip: Int, take: Int, where: Film_actorWhereInput): [Film_actor!]!
  film_category(cursor: Film_categoryWhereUniqueInput, distinct: [Film_categoryScalarFieldEnum!], orderBy: [Film_categoryOrderByWithRelationInput!], skip: Int, take: Int, where: Film_categoryWhereInput): [Film_category!]!
  film_id: Int!
  inventory(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): [Inventory!]!
  language_film_language_idTolanguage: Language!
  language_film_original_language_idTolanguage(where: LanguageWhereInput): Language
  language_id: Int!
  last_update: DateTimeISO!
  length: Int
  original_language_id: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int!
  rental_rate: Decimal!
  replacement_cost: Decimal!
  special_features: String
  title: String!
}

type FilmAvgAggregate {
  film_id: Float
  language_id: Float
  length: Float
  original_language_id: Float
  release_year: Float
  rental_duration: Float
  rental_rate: Decimal
  replacement_cost: Decimal
}

input FilmAvgOrderByAggregateInput {
  film_id: SortOrder
  language_id: SortOrder
  length: SortOrder
  original_language_id: SortOrder
  release_year: SortOrder
  rental_duration: SortOrder
  rental_rate: SortOrder
  replacement_cost: SortOrder
}

type FilmCount {
  film_actor(where: Film_actorWhereInput): Int!
  film_category(where: Film_categoryWhereInput): Int!
  inventory(where: InventoryWhereInput): Int!
}

type FilmCountAggregate {
  _all: Int!
  description: Int!
  film_id: Int!
  language_id: Int!
  last_update: Int!
  length: Int!
  original_language_id: Int!
  rating: Int!
  release_year: Int!
  rental_duration: Int!
  rental_rate: Int!
  replacement_cost: Int!
  special_features: Int!
  title: Int!
}

input FilmCountOrderByAggregateInput {
  description: SortOrder
  film_id: SortOrder
  language_id: SortOrder
  last_update: SortOrder
  length: SortOrder
  original_language_id: SortOrder
  rating: SortOrder
  release_year: SortOrder
  rental_duration: SortOrder
  rental_rate: SortOrder
  replacement_cost: SortOrder
  special_features: SortOrder
  title: SortOrder
}

input FilmCreateInput {
  description: String
  film_actor: Film_actorCreateNestedManyWithoutFilmInput
  film_category: Film_categoryCreateNestedManyWithoutFilmInput
  inventory: InventoryCreateNestedManyWithoutFilmInput
  language_film_language_idTolanguage: LanguageCreateNestedOneWithoutFilm_film_language_idTolanguageInput!
  language_film_original_language_idTolanguage: LanguageCreateNestedOneWithoutFilm_film_original_language_idTolanguageInput
  last_update: DateTimeISO
  length: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
  special_features: String
  title: String!
}

input FilmCreateManyInput {
  description: String
  film_id: Int
  language_id: Int!
  last_update: DateTimeISO
  length: Int
  original_language_id: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
  special_features: String
  title: String!
}

input FilmCreateManyLanguage_film_language_idTolanguageInput {
  description: String
  film_id: Int
  last_update: DateTimeISO
  length: Int
  original_language_id: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
  special_features: String
  title: String!
}

input FilmCreateManyLanguage_film_language_idTolanguageInputEnvelope {
  data: [FilmCreateManyLanguage_film_language_idTolanguageInput!]!
  skipDuplicates: Boolean
}

input FilmCreateManyLanguage_film_original_language_idTolanguageInput {
  description: String
  film_id: Int
  language_id: Int!
  last_update: DateTimeISO
  length: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
  special_features: String
  title: String!
}

input FilmCreateManyLanguage_film_original_language_idTolanguageInputEnvelope {
  data: [FilmCreateManyLanguage_film_original_language_idTolanguageInput!]!
  skipDuplicates: Boolean
}

input FilmCreateNestedManyWithoutLanguage_film_language_idTolanguageInput {
  connect: [FilmWhereUniqueInput!]
  connectOrCreate: [FilmCreateOrConnectWithoutLanguage_film_language_idTolanguageInput!]
  create: [FilmCreateWithoutLanguage_film_language_idTolanguageInput!]
  createMany: FilmCreateManyLanguage_film_language_idTolanguageInputEnvelope
}

input FilmCreateNestedManyWithoutLanguage_film_original_language_idTolanguageInput {
  connect: [FilmWhereUniqueInput!]
  connectOrCreate: [FilmCreateOrConnectWithoutLanguage_film_original_language_idTolanguageInput!]
  create: [FilmCreateWithoutLanguage_film_original_language_idTolanguageInput!]
  createMany: FilmCreateManyLanguage_film_original_language_idTolanguageInputEnvelope
}

input FilmCreateNestedOneWithoutFilm_actorInput {
  connect: FilmWhereUniqueInput
  connectOrCreate: FilmCreateOrConnectWithoutFilm_actorInput
  create: FilmCreateWithoutFilm_actorInput
}

input FilmCreateNestedOneWithoutFilm_categoryInput {
  connect: FilmWhereUniqueInput
  connectOrCreate: FilmCreateOrConnectWithoutFilm_categoryInput
  create: FilmCreateWithoutFilm_categoryInput
}

input FilmCreateNestedOneWithoutInventoryInput {
  connect: FilmWhereUniqueInput
  connectOrCreate: FilmCreateOrConnectWithoutInventoryInput
  create: FilmCreateWithoutInventoryInput
}

input FilmCreateOrConnectWithoutFilm_actorInput {
  create: FilmCreateWithoutFilm_actorInput!
  where: FilmWhereUniqueInput!
}

input FilmCreateOrConnectWithoutFilm_categoryInput {
  create: FilmCreateWithoutFilm_categoryInput!
  where: FilmWhereUniqueInput!
}

input FilmCreateOrConnectWithoutInventoryInput {
  create: FilmCreateWithoutInventoryInput!
  where: FilmWhereUniqueInput!
}

input FilmCreateOrConnectWithoutLanguage_film_language_idTolanguageInput {
  create: FilmCreateWithoutLanguage_film_language_idTolanguageInput!
  where: FilmWhereUniqueInput!
}

input FilmCreateOrConnectWithoutLanguage_film_original_language_idTolanguageInput {
  create: FilmCreateWithoutLanguage_film_original_language_idTolanguageInput!
  where: FilmWhereUniqueInput!
}

input FilmCreateWithoutFilm_actorInput {
  description: String
  film_category: Film_categoryCreateNestedManyWithoutFilmInput
  inventory: InventoryCreateNestedManyWithoutFilmInput
  language_film_language_idTolanguage: LanguageCreateNestedOneWithoutFilm_film_language_idTolanguageInput!
  language_film_original_language_idTolanguage: LanguageCreateNestedOneWithoutFilm_film_original_language_idTolanguageInput
  last_update: DateTimeISO
  length: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
  special_features: String
  title: String!
}

input FilmCreateWithoutFilm_categoryInput {
  description: String
  film_actor: Film_actorCreateNestedManyWithoutFilmInput
  inventory: InventoryCreateNestedManyWithoutFilmInput
  language_film_language_idTolanguage: LanguageCreateNestedOneWithoutFilm_film_language_idTolanguageInput!
  language_film_original_language_idTolanguage: LanguageCreateNestedOneWithoutFilm_film_original_language_idTolanguageInput
  last_update: DateTimeISO
  length: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
  special_features: String
  title: String!
}

input FilmCreateWithoutInventoryInput {
  description: String
  film_actor: Film_actorCreateNestedManyWithoutFilmInput
  film_category: Film_categoryCreateNestedManyWithoutFilmInput
  language_film_language_idTolanguage: LanguageCreateNestedOneWithoutFilm_film_language_idTolanguageInput!
  language_film_original_language_idTolanguage: LanguageCreateNestedOneWithoutFilm_film_original_language_idTolanguageInput
  last_update: DateTimeISO
  length: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
  special_features: String
  title: String!
}

input FilmCreateWithoutLanguage_film_language_idTolanguageInput {
  description: String
  film_actor: Film_actorCreateNestedManyWithoutFilmInput
  film_category: Film_categoryCreateNestedManyWithoutFilmInput
  inventory: InventoryCreateNestedManyWithoutFilmInput
  language_film_original_language_idTolanguage: LanguageCreateNestedOneWithoutFilm_film_original_language_idTolanguageInput
  last_update: DateTimeISO
  length: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
  special_features: String
  title: String!
}

input FilmCreateWithoutLanguage_film_original_language_idTolanguageInput {
  description: String
  film_actor: Film_actorCreateNestedManyWithoutFilmInput
  film_category: Film_categoryCreateNestedManyWithoutFilmInput
  inventory: InventoryCreateNestedManyWithoutFilmInput
  language_film_language_idTolanguage: LanguageCreateNestedOneWithoutFilm_film_language_idTolanguageInput!
  last_update: DateTimeISO
  length: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
  special_features: String
  title: String!
}

type FilmGroupBy {
  _avg: FilmAvgAggregate
  _count: FilmCountAggregate
  _max: FilmMaxAggregate
  _min: FilmMinAggregate
  _sum: FilmSumAggregate
  description: String
  film_id: Int!
  language_id: Int!
  last_update: DateTimeISO!
  length: Int
  original_language_id: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int!
  rental_rate: Decimal!
  replacement_cost: Decimal!
  special_features: String
  title: String!
}

input FilmListRelationFilter {
  every: FilmWhereInput
  none: FilmWhereInput
  some: FilmWhereInput
}

type FilmMaxAggregate {
  description: String
  film_id: Int
  language_id: Int
  last_update: DateTimeISO
  length: Int
  original_language_id: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
  special_features: String
  title: String
}

input FilmMaxOrderByAggregateInput {
  description: SortOrder
  film_id: SortOrder
  language_id: SortOrder
  last_update: SortOrder
  length: SortOrder
  original_language_id: SortOrder
  rating: SortOrder
  release_year: SortOrder
  rental_duration: SortOrder
  rental_rate: SortOrder
  replacement_cost: SortOrder
  special_features: SortOrder
  title: SortOrder
}

type FilmMinAggregate {
  description: String
  film_id: Int
  language_id: Int
  last_update: DateTimeISO
  length: Int
  original_language_id: Int
  rating: film_rating
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
  special_features: String
  title: String
}

input FilmMinOrderByAggregateInput {
  description: SortOrder
  film_id: SortOrder
  language_id: SortOrder
  last_update: SortOrder
  length: SortOrder
  original_language_id: SortOrder
  rating: SortOrder
  release_year: SortOrder
  rental_duration: SortOrder
  rental_rate: SortOrder
  replacement_cost: SortOrder
  special_features: SortOrder
  title: SortOrder
}

input FilmOrderByRelationAggregateInput {
  _count: SortOrder
}

input FilmOrderByWithAggregationInput {
  _avg: FilmAvgOrderByAggregateInput
  _count: FilmCountOrderByAggregateInput
  _max: FilmMaxOrderByAggregateInput
  _min: FilmMinOrderByAggregateInput
  _sum: FilmSumOrderByAggregateInput
  description: SortOrderInput
  film_id: SortOrder
  language_id: SortOrder
  last_update: SortOrder
  length: SortOrderInput
  original_language_id: SortOrderInput
  rating: SortOrderInput
  release_year: SortOrderInput
  rental_duration: SortOrder
  rental_rate: SortOrder
  replacement_cost: SortOrder
  special_features: SortOrderInput
  title: SortOrder
}

input FilmOrderByWithRelationInput {
  description: SortOrderInput
  film_actor: Film_actorOrderByRelationAggregateInput
  film_category: Film_categoryOrderByRelationAggregateInput
  film_id: SortOrder
  inventory: InventoryOrderByRelationAggregateInput
  language_film_language_idTolanguage: LanguageOrderByWithRelationInput
  language_film_original_language_idTolanguage: LanguageOrderByWithRelationInput
  language_id: SortOrder
  last_update: SortOrder
  length: SortOrderInput
  original_language_id: SortOrderInput
  rating: SortOrderInput
  release_year: SortOrderInput
  rental_duration: SortOrder
  rental_rate: SortOrder
  replacement_cost: SortOrder
  special_features: SortOrderInput
  title: SortOrder
}

input FilmRelationFilter {
  is: FilmWhereInput
  isNot: FilmWhereInput
}

enum FilmScalarFieldEnum {
  description
  film_id
  language_id
  last_update
  length
  original_language_id
  rating
  release_year
  rental_duration
  rental_rate
  replacement_cost
  special_features
  title
}

input FilmScalarWhereInput {
  AND: [FilmScalarWhereInput!]
  NOT: [FilmScalarWhereInput!]
  OR: [FilmScalarWhereInput!]
  description: StringNullableFilter
  film_id: IntFilter
  language_id: IntFilter
  last_update: DateTimeFilter
  length: IntNullableFilter
  original_language_id: IntNullableFilter
  rating: Enumfilm_ratingNullableFilter
  release_year: IntNullableFilter
  rental_duration: IntFilter
  rental_rate: DecimalFilter
  replacement_cost: DecimalFilter
  special_features: StringNullableFilter
  title: StringFilter
}

input FilmScalarWhereWithAggregatesInput {
  AND: [FilmScalarWhereWithAggregatesInput!]
  NOT: [FilmScalarWhereWithAggregatesInput!]
  OR: [FilmScalarWhereWithAggregatesInput!]
  description: StringNullableWithAggregatesFilter
  film_id: IntWithAggregatesFilter
  language_id: IntWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
  length: IntNullableWithAggregatesFilter
  original_language_id: IntNullableWithAggregatesFilter
  rating: Enumfilm_ratingNullableWithAggregatesFilter
  release_year: IntNullableWithAggregatesFilter
  rental_duration: IntWithAggregatesFilter
  rental_rate: DecimalWithAggregatesFilter
  replacement_cost: DecimalWithAggregatesFilter
  special_features: StringNullableWithAggregatesFilter
  title: StringWithAggregatesFilter
}

type FilmSumAggregate {
  film_id: Int
  language_id: Int
  length: Int
  original_language_id: Int
  release_year: Int
  rental_duration: Int
  rental_rate: Decimal
  replacement_cost: Decimal
}

input FilmSumOrderByAggregateInput {
  film_id: SortOrder
  language_id: SortOrder
  length: SortOrder
  original_language_id: SortOrder
  release_year: SortOrder
  rental_duration: SortOrder
  rental_rate: SortOrder
  replacement_cost: SortOrder
}

input FilmUpdateInput {
  description: NullableStringFieldUpdateOperationsInput
  film_actor: Film_actorUpdateManyWithoutFilmNestedInput
  film_category: Film_categoryUpdateManyWithoutFilmNestedInput
  inventory: InventoryUpdateManyWithoutFilmNestedInput
  language_film_language_idTolanguage: LanguageUpdateOneRequiredWithoutFilm_film_language_idTolanguageNestedInput
  language_film_original_language_idTolanguage: LanguageUpdateOneWithoutFilm_film_original_language_idTolanguageNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  length: NullableIntFieldUpdateOperationsInput
  rating: NullableEnumfilm_ratingFieldUpdateOperationsInput
  release_year: NullableIntFieldUpdateOperationsInput
  rental_duration: IntFieldUpdateOperationsInput
  rental_rate: DecimalFieldUpdateOperationsInput
  replacement_cost: DecimalFieldUpdateOperationsInput
  special_features: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input FilmUpdateManyMutationInput {
  description: NullableStringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  length: NullableIntFieldUpdateOperationsInput
  rating: NullableEnumfilm_ratingFieldUpdateOperationsInput
  release_year: NullableIntFieldUpdateOperationsInput
  rental_duration: IntFieldUpdateOperationsInput
  rental_rate: DecimalFieldUpdateOperationsInput
  replacement_cost: DecimalFieldUpdateOperationsInput
  special_features: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input FilmUpdateManyWithWhereWithoutLanguage_film_language_idTolanguageInput {
  data: FilmUpdateManyMutationInput!
  where: FilmScalarWhereInput!
}

input FilmUpdateManyWithWhereWithoutLanguage_film_original_language_idTolanguageInput {
  data: FilmUpdateManyMutationInput!
  where: FilmScalarWhereInput!
}

input FilmUpdateManyWithoutLanguage_film_language_idTolanguageNestedInput {
  connect: [FilmWhereUniqueInput!]
  connectOrCreate: [FilmCreateOrConnectWithoutLanguage_film_language_idTolanguageInput!]
  create: [FilmCreateWithoutLanguage_film_language_idTolanguageInput!]
  createMany: FilmCreateManyLanguage_film_language_idTolanguageInputEnvelope
  delete: [FilmWhereUniqueInput!]
  deleteMany: [FilmScalarWhereInput!]
  disconnect: [FilmWhereUniqueInput!]
  set: [FilmWhereUniqueInput!]
  update: [FilmUpdateWithWhereUniqueWithoutLanguage_film_language_idTolanguageInput!]
  updateMany: [FilmUpdateManyWithWhereWithoutLanguage_film_language_idTolanguageInput!]
  upsert: [FilmUpsertWithWhereUniqueWithoutLanguage_film_language_idTolanguageInput!]
}

input FilmUpdateManyWithoutLanguage_film_original_language_idTolanguageNestedInput {
  connect: [FilmWhereUniqueInput!]
  connectOrCreate: [FilmCreateOrConnectWithoutLanguage_film_original_language_idTolanguageInput!]
  create: [FilmCreateWithoutLanguage_film_original_language_idTolanguageInput!]
  createMany: FilmCreateManyLanguage_film_original_language_idTolanguageInputEnvelope
  delete: [FilmWhereUniqueInput!]
  deleteMany: [FilmScalarWhereInput!]
  disconnect: [FilmWhereUniqueInput!]
  set: [FilmWhereUniqueInput!]
  update: [FilmUpdateWithWhereUniqueWithoutLanguage_film_original_language_idTolanguageInput!]
  updateMany: [FilmUpdateManyWithWhereWithoutLanguage_film_original_language_idTolanguageInput!]
  upsert: [FilmUpsertWithWhereUniqueWithoutLanguage_film_original_language_idTolanguageInput!]
}

input FilmUpdateOneRequiredWithoutFilm_actorNestedInput {
  connect: FilmWhereUniqueInput
  connectOrCreate: FilmCreateOrConnectWithoutFilm_actorInput
  create: FilmCreateWithoutFilm_actorInput
  update: FilmUpdateToOneWithWhereWithoutFilm_actorInput
  upsert: FilmUpsertWithoutFilm_actorInput
}

input FilmUpdateOneRequiredWithoutFilm_categoryNestedInput {
  connect: FilmWhereUniqueInput
  connectOrCreate: FilmCreateOrConnectWithoutFilm_categoryInput
  create: FilmCreateWithoutFilm_categoryInput
  update: FilmUpdateToOneWithWhereWithoutFilm_categoryInput
  upsert: FilmUpsertWithoutFilm_categoryInput
}

input FilmUpdateOneRequiredWithoutInventoryNestedInput {
  connect: FilmWhereUniqueInput
  connectOrCreate: FilmCreateOrConnectWithoutInventoryInput
  create: FilmCreateWithoutInventoryInput
  update: FilmUpdateToOneWithWhereWithoutInventoryInput
  upsert: FilmUpsertWithoutInventoryInput
}

input FilmUpdateToOneWithWhereWithoutFilm_actorInput {
  data: FilmUpdateWithoutFilm_actorInput!
  where: FilmWhereInput
}

input FilmUpdateToOneWithWhereWithoutFilm_categoryInput {
  data: FilmUpdateWithoutFilm_categoryInput!
  where: FilmWhereInput
}

input FilmUpdateToOneWithWhereWithoutInventoryInput {
  data: FilmUpdateWithoutInventoryInput!
  where: FilmWhereInput
}

input FilmUpdateWithWhereUniqueWithoutLanguage_film_language_idTolanguageInput {
  data: FilmUpdateWithoutLanguage_film_language_idTolanguageInput!
  where: FilmWhereUniqueInput!
}

input FilmUpdateWithWhereUniqueWithoutLanguage_film_original_language_idTolanguageInput {
  data: FilmUpdateWithoutLanguage_film_original_language_idTolanguageInput!
  where: FilmWhereUniqueInput!
}

input FilmUpdateWithoutFilm_actorInput {
  description: NullableStringFieldUpdateOperationsInput
  film_category: Film_categoryUpdateManyWithoutFilmNestedInput
  inventory: InventoryUpdateManyWithoutFilmNestedInput
  language_film_language_idTolanguage: LanguageUpdateOneRequiredWithoutFilm_film_language_idTolanguageNestedInput
  language_film_original_language_idTolanguage: LanguageUpdateOneWithoutFilm_film_original_language_idTolanguageNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  length: NullableIntFieldUpdateOperationsInput
  rating: NullableEnumfilm_ratingFieldUpdateOperationsInput
  release_year: NullableIntFieldUpdateOperationsInput
  rental_duration: IntFieldUpdateOperationsInput
  rental_rate: DecimalFieldUpdateOperationsInput
  replacement_cost: DecimalFieldUpdateOperationsInput
  special_features: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input FilmUpdateWithoutFilm_categoryInput {
  description: NullableStringFieldUpdateOperationsInput
  film_actor: Film_actorUpdateManyWithoutFilmNestedInput
  inventory: InventoryUpdateManyWithoutFilmNestedInput
  language_film_language_idTolanguage: LanguageUpdateOneRequiredWithoutFilm_film_language_idTolanguageNestedInput
  language_film_original_language_idTolanguage: LanguageUpdateOneWithoutFilm_film_original_language_idTolanguageNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  length: NullableIntFieldUpdateOperationsInput
  rating: NullableEnumfilm_ratingFieldUpdateOperationsInput
  release_year: NullableIntFieldUpdateOperationsInput
  rental_duration: IntFieldUpdateOperationsInput
  rental_rate: DecimalFieldUpdateOperationsInput
  replacement_cost: DecimalFieldUpdateOperationsInput
  special_features: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input FilmUpdateWithoutInventoryInput {
  description: NullableStringFieldUpdateOperationsInput
  film_actor: Film_actorUpdateManyWithoutFilmNestedInput
  film_category: Film_categoryUpdateManyWithoutFilmNestedInput
  language_film_language_idTolanguage: LanguageUpdateOneRequiredWithoutFilm_film_language_idTolanguageNestedInput
  language_film_original_language_idTolanguage: LanguageUpdateOneWithoutFilm_film_original_language_idTolanguageNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  length: NullableIntFieldUpdateOperationsInput
  rating: NullableEnumfilm_ratingFieldUpdateOperationsInput
  release_year: NullableIntFieldUpdateOperationsInput
  rental_duration: IntFieldUpdateOperationsInput
  rental_rate: DecimalFieldUpdateOperationsInput
  replacement_cost: DecimalFieldUpdateOperationsInput
  special_features: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input FilmUpdateWithoutLanguage_film_language_idTolanguageInput {
  description: NullableStringFieldUpdateOperationsInput
  film_actor: Film_actorUpdateManyWithoutFilmNestedInput
  film_category: Film_categoryUpdateManyWithoutFilmNestedInput
  inventory: InventoryUpdateManyWithoutFilmNestedInput
  language_film_original_language_idTolanguage: LanguageUpdateOneWithoutFilm_film_original_language_idTolanguageNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  length: NullableIntFieldUpdateOperationsInput
  rating: NullableEnumfilm_ratingFieldUpdateOperationsInput
  release_year: NullableIntFieldUpdateOperationsInput
  rental_duration: IntFieldUpdateOperationsInput
  rental_rate: DecimalFieldUpdateOperationsInput
  replacement_cost: DecimalFieldUpdateOperationsInput
  special_features: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input FilmUpdateWithoutLanguage_film_original_language_idTolanguageInput {
  description: NullableStringFieldUpdateOperationsInput
  film_actor: Film_actorUpdateManyWithoutFilmNestedInput
  film_category: Film_categoryUpdateManyWithoutFilmNestedInput
  inventory: InventoryUpdateManyWithoutFilmNestedInput
  language_film_language_idTolanguage: LanguageUpdateOneRequiredWithoutFilm_film_language_idTolanguageNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  length: NullableIntFieldUpdateOperationsInput
  rating: NullableEnumfilm_ratingFieldUpdateOperationsInput
  release_year: NullableIntFieldUpdateOperationsInput
  rental_duration: IntFieldUpdateOperationsInput
  rental_rate: DecimalFieldUpdateOperationsInput
  replacement_cost: DecimalFieldUpdateOperationsInput
  special_features: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input FilmUpsertWithWhereUniqueWithoutLanguage_film_language_idTolanguageInput {
  create: FilmCreateWithoutLanguage_film_language_idTolanguageInput!
  update: FilmUpdateWithoutLanguage_film_language_idTolanguageInput!
  where: FilmWhereUniqueInput!
}

input FilmUpsertWithWhereUniqueWithoutLanguage_film_original_language_idTolanguageInput {
  create: FilmCreateWithoutLanguage_film_original_language_idTolanguageInput!
  update: FilmUpdateWithoutLanguage_film_original_language_idTolanguageInput!
  where: FilmWhereUniqueInput!
}

input FilmUpsertWithoutFilm_actorInput {
  create: FilmCreateWithoutFilm_actorInput!
  update: FilmUpdateWithoutFilm_actorInput!
  where: FilmWhereInput
}

input FilmUpsertWithoutFilm_categoryInput {
  create: FilmCreateWithoutFilm_categoryInput!
  update: FilmUpdateWithoutFilm_categoryInput!
  where: FilmWhereInput
}

input FilmUpsertWithoutInventoryInput {
  create: FilmCreateWithoutInventoryInput!
  update: FilmUpdateWithoutInventoryInput!
  where: FilmWhereInput
}

input FilmWhereInput {
  AND: [FilmWhereInput!]
  NOT: [FilmWhereInput!]
  OR: [FilmWhereInput!]
  description: StringNullableFilter
  film_actor: Film_actorListRelationFilter
  film_category: Film_categoryListRelationFilter
  film_id: IntFilter
  inventory: InventoryListRelationFilter
  language_film_language_idTolanguage: LanguageRelationFilter
  language_film_original_language_idTolanguage: LanguageNullableRelationFilter
  language_id: IntFilter
  last_update: DateTimeFilter
  length: IntNullableFilter
  original_language_id: IntNullableFilter
  rating: Enumfilm_ratingNullableFilter
  release_year: IntNullableFilter
  rental_duration: IntFilter
  rental_rate: DecimalFilter
  replacement_cost: DecimalFilter
  special_features: StringNullableFilter
  title: StringFilter
}

input FilmWhereUniqueInput {
  AND: [FilmWhereInput!]
  NOT: [FilmWhereInput!]
  OR: [FilmWhereInput!]
  description: StringNullableFilter
  film_actor: Film_actorListRelationFilter
  film_category: Film_categoryListRelationFilter
  film_id: Int
  inventory: InventoryListRelationFilter
  language_film_language_idTolanguage: LanguageRelationFilter
  language_film_original_language_idTolanguage: LanguageNullableRelationFilter
  language_id: IntFilter
  last_update: DateTimeFilter
  length: IntNullableFilter
  original_language_id: IntNullableFilter
  rating: Enumfilm_ratingNullableFilter
  release_year: IntNullableFilter
  rental_duration: IntFilter
  rental_rate: DecimalFilter
  replacement_cost: DecimalFilter
  special_features: StringNullableFilter
  title: StringFilter
}

type Film_actor {
  actor: Actor!
  actor_id: Int!
  film: Film!
  film_id: Int!
  last_update: DateTimeISO!
}

type Film_actorAvgAggregate {
  actor_id: Float
  film_id: Float
}

input Film_actorAvgOrderByAggregateInput {
  actor_id: SortOrder
  film_id: SortOrder
}

type Film_actorCountAggregate {
  _all: Int!
  actor_id: Int!
  film_id: Int!
  last_update: Int!
}

input Film_actorCountOrderByAggregateInput {
  actor_id: SortOrder
  film_id: SortOrder
  last_update: SortOrder
}

input Film_actorCreateInput {
  actor: ActorCreateNestedOneWithoutFilm_actorInput!
  film: FilmCreateNestedOneWithoutFilm_actorInput!
  last_update: DateTimeISO
}

input Film_actorCreateManyActorInput {
  film_id: Int!
  last_update: DateTimeISO
}

input Film_actorCreateManyActorInputEnvelope {
  data: [Film_actorCreateManyActorInput!]!
  skipDuplicates: Boolean
}

input Film_actorCreateManyFilmInput {
  actor_id: Int!
  last_update: DateTimeISO
}

input Film_actorCreateManyFilmInputEnvelope {
  data: [Film_actorCreateManyFilmInput!]!
  skipDuplicates: Boolean
}

input Film_actorCreateManyInput {
  actor_id: Int!
  film_id: Int!
  last_update: DateTimeISO
}

input Film_actorCreateNestedManyWithoutActorInput {
  connect: [Film_actorWhereUniqueInput!]
  connectOrCreate: [Film_actorCreateOrConnectWithoutActorInput!]
  create: [Film_actorCreateWithoutActorInput!]
  createMany: Film_actorCreateManyActorInputEnvelope
}

input Film_actorCreateNestedManyWithoutFilmInput {
  connect: [Film_actorWhereUniqueInput!]
  connectOrCreate: [Film_actorCreateOrConnectWithoutFilmInput!]
  create: [Film_actorCreateWithoutFilmInput!]
  createMany: Film_actorCreateManyFilmInputEnvelope
}

input Film_actorCreateOrConnectWithoutActorInput {
  create: Film_actorCreateWithoutActorInput!
  where: Film_actorWhereUniqueInput!
}

input Film_actorCreateOrConnectWithoutFilmInput {
  create: Film_actorCreateWithoutFilmInput!
  where: Film_actorWhereUniqueInput!
}

input Film_actorCreateWithoutActorInput {
  film: FilmCreateNestedOneWithoutFilm_actorInput!
  last_update: DateTimeISO
}

input Film_actorCreateWithoutFilmInput {
  actor: ActorCreateNestedOneWithoutFilm_actorInput!
  last_update: DateTimeISO
}

type Film_actorGroupBy {
  _avg: Film_actorAvgAggregate
  _count: Film_actorCountAggregate
  _max: Film_actorMaxAggregate
  _min: Film_actorMinAggregate
  _sum: Film_actorSumAggregate
  actor_id: Int!
  film_id: Int!
  last_update: DateTimeISO!
}

input Film_actorListRelationFilter {
  every: Film_actorWhereInput
  none: Film_actorWhereInput
  some: Film_actorWhereInput
}

type Film_actorMaxAggregate {
  actor_id: Int
  film_id: Int
  last_update: DateTimeISO
}

input Film_actorMaxOrderByAggregateInput {
  actor_id: SortOrder
  film_id: SortOrder
  last_update: SortOrder
}

type Film_actorMinAggregate {
  actor_id: Int
  film_id: Int
  last_update: DateTimeISO
}

input Film_actorMinOrderByAggregateInput {
  actor_id: SortOrder
  film_id: SortOrder
  last_update: SortOrder
}

input Film_actorOrderByRelationAggregateInput {
  _count: SortOrder
}

input Film_actorOrderByWithAggregationInput {
  _avg: Film_actorAvgOrderByAggregateInput
  _count: Film_actorCountOrderByAggregateInput
  _max: Film_actorMaxOrderByAggregateInput
  _min: Film_actorMinOrderByAggregateInput
  _sum: Film_actorSumOrderByAggregateInput
  actor_id: SortOrder
  film_id: SortOrder
  last_update: SortOrder
}

input Film_actorOrderByWithRelationInput {
  actor: ActorOrderByWithRelationInput
  actor_id: SortOrder
  film: FilmOrderByWithRelationInput
  film_id: SortOrder
  last_update: SortOrder
}

enum Film_actorScalarFieldEnum {
  actor_id
  film_id
  last_update
}

input Film_actorScalarWhereInput {
  AND: [Film_actorScalarWhereInput!]
  NOT: [Film_actorScalarWhereInput!]
  OR: [Film_actorScalarWhereInput!]
  actor_id: IntFilter
  film_id: IntFilter
  last_update: DateTimeFilter
}

input Film_actorScalarWhereWithAggregatesInput {
  AND: [Film_actorScalarWhereWithAggregatesInput!]
  NOT: [Film_actorScalarWhereWithAggregatesInput!]
  OR: [Film_actorScalarWhereWithAggregatesInput!]
  actor_id: IntWithAggregatesFilter
  film_id: IntWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
}

type Film_actorSumAggregate {
  actor_id: Int
  film_id: Int
}

input Film_actorSumOrderByAggregateInput {
  actor_id: SortOrder
  film_id: SortOrder
}

input Film_actorUpdateInput {
  actor: ActorUpdateOneRequiredWithoutFilm_actorNestedInput
  film: FilmUpdateOneRequiredWithoutFilm_actorNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input Film_actorUpdateManyMutationInput {
  last_update: DateTimeFieldUpdateOperationsInput
}

input Film_actorUpdateManyWithWhereWithoutActorInput {
  data: Film_actorUpdateManyMutationInput!
  where: Film_actorScalarWhereInput!
}

input Film_actorUpdateManyWithWhereWithoutFilmInput {
  data: Film_actorUpdateManyMutationInput!
  where: Film_actorScalarWhereInput!
}

input Film_actorUpdateManyWithoutActorNestedInput {
  connect: [Film_actorWhereUniqueInput!]
  connectOrCreate: [Film_actorCreateOrConnectWithoutActorInput!]
  create: [Film_actorCreateWithoutActorInput!]
  createMany: Film_actorCreateManyActorInputEnvelope
  delete: [Film_actorWhereUniqueInput!]
  deleteMany: [Film_actorScalarWhereInput!]
  disconnect: [Film_actorWhereUniqueInput!]
  set: [Film_actorWhereUniqueInput!]
  update: [Film_actorUpdateWithWhereUniqueWithoutActorInput!]
  updateMany: [Film_actorUpdateManyWithWhereWithoutActorInput!]
  upsert: [Film_actorUpsertWithWhereUniqueWithoutActorInput!]
}

input Film_actorUpdateManyWithoutFilmNestedInput {
  connect: [Film_actorWhereUniqueInput!]
  connectOrCreate: [Film_actorCreateOrConnectWithoutFilmInput!]
  create: [Film_actorCreateWithoutFilmInput!]
  createMany: Film_actorCreateManyFilmInputEnvelope
  delete: [Film_actorWhereUniqueInput!]
  deleteMany: [Film_actorScalarWhereInput!]
  disconnect: [Film_actorWhereUniqueInput!]
  set: [Film_actorWhereUniqueInput!]
  update: [Film_actorUpdateWithWhereUniqueWithoutFilmInput!]
  updateMany: [Film_actorUpdateManyWithWhereWithoutFilmInput!]
  upsert: [Film_actorUpsertWithWhereUniqueWithoutFilmInput!]
}

input Film_actorUpdateWithWhereUniqueWithoutActorInput {
  data: Film_actorUpdateWithoutActorInput!
  where: Film_actorWhereUniqueInput!
}

input Film_actorUpdateWithWhereUniqueWithoutFilmInput {
  data: Film_actorUpdateWithoutFilmInput!
  where: Film_actorWhereUniqueInput!
}

input Film_actorUpdateWithoutActorInput {
  film: FilmUpdateOneRequiredWithoutFilm_actorNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input Film_actorUpdateWithoutFilmInput {
  actor: ActorUpdateOneRequiredWithoutFilm_actorNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input Film_actorUpsertWithWhereUniqueWithoutActorInput {
  create: Film_actorCreateWithoutActorInput!
  update: Film_actorUpdateWithoutActorInput!
  where: Film_actorWhereUniqueInput!
}

input Film_actorUpsertWithWhereUniqueWithoutFilmInput {
  create: Film_actorCreateWithoutFilmInput!
  update: Film_actorUpdateWithoutFilmInput!
  where: Film_actorWhereUniqueInput!
}

input Film_actorWhereInput {
  AND: [Film_actorWhereInput!]
  NOT: [Film_actorWhereInput!]
  OR: [Film_actorWhereInput!]
  actor: ActorRelationFilter
  actor_id: IntFilter
  film: FilmRelationFilter
  film_id: IntFilter
  last_update: DateTimeFilter
}

input Film_actorWhereUniqueInput {
  AND: [Film_actorWhereInput!]
  NOT: [Film_actorWhereInput!]
  OR: [Film_actorWhereInput!]
  actor: ActorRelationFilter
  actor_id: IntFilter
  actor_id_film_id: film_actorActor_idFilm_idCompoundUniqueInput
  film: FilmRelationFilter
  film_id: IntFilter
  last_update: DateTimeFilter
}

type Film_category {
  category: Category!
  category_id: Int!
  film: Film!
  film_id: Int!
  last_update: DateTimeISO!
}

type Film_categoryAvgAggregate {
  category_id: Float
  film_id: Float
}

input Film_categoryAvgOrderByAggregateInput {
  category_id: SortOrder
  film_id: SortOrder
}

type Film_categoryCountAggregate {
  _all: Int!
  category_id: Int!
  film_id: Int!
  last_update: Int!
}

input Film_categoryCountOrderByAggregateInput {
  category_id: SortOrder
  film_id: SortOrder
  last_update: SortOrder
}

input Film_categoryCreateInput {
  category: CategoryCreateNestedOneWithoutFilm_categoryInput!
  film: FilmCreateNestedOneWithoutFilm_categoryInput!
  last_update: DateTimeISO
}

input Film_categoryCreateManyCategoryInput {
  film_id: Int!
  last_update: DateTimeISO
}

input Film_categoryCreateManyCategoryInputEnvelope {
  data: [Film_categoryCreateManyCategoryInput!]!
  skipDuplicates: Boolean
}

input Film_categoryCreateManyFilmInput {
  category_id: Int!
  last_update: DateTimeISO
}

input Film_categoryCreateManyFilmInputEnvelope {
  data: [Film_categoryCreateManyFilmInput!]!
  skipDuplicates: Boolean
}

input Film_categoryCreateManyInput {
  category_id: Int!
  film_id: Int!
  last_update: DateTimeISO
}

input Film_categoryCreateNestedManyWithoutCategoryInput {
  connect: [Film_categoryWhereUniqueInput!]
  connectOrCreate: [Film_categoryCreateOrConnectWithoutCategoryInput!]
  create: [Film_categoryCreateWithoutCategoryInput!]
  createMany: Film_categoryCreateManyCategoryInputEnvelope
}

input Film_categoryCreateNestedManyWithoutFilmInput {
  connect: [Film_categoryWhereUniqueInput!]
  connectOrCreate: [Film_categoryCreateOrConnectWithoutFilmInput!]
  create: [Film_categoryCreateWithoutFilmInput!]
  createMany: Film_categoryCreateManyFilmInputEnvelope
}

input Film_categoryCreateOrConnectWithoutCategoryInput {
  create: Film_categoryCreateWithoutCategoryInput!
  where: Film_categoryWhereUniqueInput!
}

input Film_categoryCreateOrConnectWithoutFilmInput {
  create: Film_categoryCreateWithoutFilmInput!
  where: Film_categoryWhereUniqueInput!
}

input Film_categoryCreateWithoutCategoryInput {
  film: FilmCreateNestedOneWithoutFilm_categoryInput!
  last_update: DateTimeISO
}

input Film_categoryCreateWithoutFilmInput {
  category: CategoryCreateNestedOneWithoutFilm_categoryInput!
  last_update: DateTimeISO
}

type Film_categoryGroupBy {
  _avg: Film_categoryAvgAggregate
  _count: Film_categoryCountAggregate
  _max: Film_categoryMaxAggregate
  _min: Film_categoryMinAggregate
  _sum: Film_categorySumAggregate
  category_id: Int!
  film_id: Int!
  last_update: DateTimeISO!
}

input Film_categoryListRelationFilter {
  every: Film_categoryWhereInput
  none: Film_categoryWhereInput
  some: Film_categoryWhereInput
}

type Film_categoryMaxAggregate {
  category_id: Int
  film_id: Int
  last_update: DateTimeISO
}

input Film_categoryMaxOrderByAggregateInput {
  category_id: SortOrder
  film_id: SortOrder
  last_update: SortOrder
}

type Film_categoryMinAggregate {
  category_id: Int
  film_id: Int
  last_update: DateTimeISO
}

input Film_categoryMinOrderByAggregateInput {
  category_id: SortOrder
  film_id: SortOrder
  last_update: SortOrder
}

input Film_categoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input Film_categoryOrderByWithAggregationInput {
  _avg: Film_categoryAvgOrderByAggregateInput
  _count: Film_categoryCountOrderByAggregateInput
  _max: Film_categoryMaxOrderByAggregateInput
  _min: Film_categoryMinOrderByAggregateInput
  _sum: Film_categorySumOrderByAggregateInput
  category_id: SortOrder
  film_id: SortOrder
  last_update: SortOrder
}

input Film_categoryOrderByWithRelationInput {
  category: CategoryOrderByWithRelationInput
  category_id: SortOrder
  film: FilmOrderByWithRelationInput
  film_id: SortOrder
  last_update: SortOrder
}

enum Film_categoryScalarFieldEnum {
  category_id
  film_id
  last_update
}

input Film_categoryScalarWhereInput {
  AND: [Film_categoryScalarWhereInput!]
  NOT: [Film_categoryScalarWhereInput!]
  OR: [Film_categoryScalarWhereInput!]
  category_id: IntFilter
  film_id: IntFilter
  last_update: DateTimeFilter
}

input Film_categoryScalarWhereWithAggregatesInput {
  AND: [Film_categoryScalarWhereWithAggregatesInput!]
  NOT: [Film_categoryScalarWhereWithAggregatesInput!]
  OR: [Film_categoryScalarWhereWithAggregatesInput!]
  category_id: IntWithAggregatesFilter
  film_id: IntWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
}

type Film_categorySumAggregate {
  category_id: Int
  film_id: Int
}

input Film_categorySumOrderByAggregateInput {
  category_id: SortOrder
  film_id: SortOrder
}

input Film_categoryUpdateInput {
  category: CategoryUpdateOneRequiredWithoutFilm_categoryNestedInput
  film: FilmUpdateOneRequiredWithoutFilm_categoryNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input Film_categoryUpdateManyMutationInput {
  last_update: DateTimeFieldUpdateOperationsInput
}

input Film_categoryUpdateManyWithWhereWithoutCategoryInput {
  data: Film_categoryUpdateManyMutationInput!
  where: Film_categoryScalarWhereInput!
}

input Film_categoryUpdateManyWithWhereWithoutFilmInput {
  data: Film_categoryUpdateManyMutationInput!
  where: Film_categoryScalarWhereInput!
}

input Film_categoryUpdateManyWithoutCategoryNestedInput {
  connect: [Film_categoryWhereUniqueInput!]
  connectOrCreate: [Film_categoryCreateOrConnectWithoutCategoryInput!]
  create: [Film_categoryCreateWithoutCategoryInput!]
  createMany: Film_categoryCreateManyCategoryInputEnvelope
  delete: [Film_categoryWhereUniqueInput!]
  deleteMany: [Film_categoryScalarWhereInput!]
  disconnect: [Film_categoryWhereUniqueInput!]
  set: [Film_categoryWhereUniqueInput!]
  update: [Film_categoryUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [Film_categoryUpdateManyWithWhereWithoutCategoryInput!]
  upsert: [Film_categoryUpsertWithWhereUniqueWithoutCategoryInput!]
}

input Film_categoryUpdateManyWithoutFilmNestedInput {
  connect: [Film_categoryWhereUniqueInput!]
  connectOrCreate: [Film_categoryCreateOrConnectWithoutFilmInput!]
  create: [Film_categoryCreateWithoutFilmInput!]
  createMany: Film_categoryCreateManyFilmInputEnvelope
  delete: [Film_categoryWhereUniqueInput!]
  deleteMany: [Film_categoryScalarWhereInput!]
  disconnect: [Film_categoryWhereUniqueInput!]
  set: [Film_categoryWhereUniqueInput!]
  update: [Film_categoryUpdateWithWhereUniqueWithoutFilmInput!]
  updateMany: [Film_categoryUpdateManyWithWhereWithoutFilmInput!]
  upsert: [Film_categoryUpsertWithWhereUniqueWithoutFilmInput!]
}

input Film_categoryUpdateWithWhereUniqueWithoutCategoryInput {
  data: Film_categoryUpdateWithoutCategoryInput!
  where: Film_categoryWhereUniqueInput!
}

input Film_categoryUpdateWithWhereUniqueWithoutFilmInput {
  data: Film_categoryUpdateWithoutFilmInput!
  where: Film_categoryWhereUniqueInput!
}

input Film_categoryUpdateWithoutCategoryInput {
  film: FilmUpdateOneRequiredWithoutFilm_categoryNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input Film_categoryUpdateWithoutFilmInput {
  category: CategoryUpdateOneRequiredWithoutFilm_categoryNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
}

input Film_categoryUpsertWithWhereUniqueWithoutCategoryInput {
  create: Film_categoryCreateWithoutCategoryInput!
  update: Film_categoryUpdateWithoutCategoryInput!
  where: Film_categoryWhereUniqueInput!
}

input Film_categoryUpsertWithWhereUniqueWithoutFilmInput {
  create: Film_categoryCreateWithoutFilmInput!
  update: Film_categoryUpdateWithoutFilmInput!
  where: Film_categoryWhereUniqueInput!
}

input Film_categoryWhereInput {
  AND: [Film_categoryWhereInput!]
  NOT: [Film_categoryWhereInput!]
  OR: [Film_categoryWhereInput!]
  category: CategoryRelationFilter
  category_id: IntFilter
  film: FilmRelationFilter
  film_id: IntFilter
  last_update: DateTimeFilter
}

input Film_categoryWhereUniqueInput {
  AND: [Film_categoryWhereInput!]
  NOT: [Film_categoryWhereInput!]
  OR: [Film_categoryWhereInput!]
  category: CategoryRelationFilter
  category_id: IntFilter
  film: FilmRelationFilter
  film_id: IntFilter
  film_id_category_id: film_categoryFilm_idCategory_idCompoundUniqueInput
  last_update: DateTimeFilter
}

type Film_text {
  description: String
  film_id: Int!
  title: String!
}

type Film_textAvgAggregate {
  film_id: Float
}

input Film_textAvgOrderByAggregateInput {
  film_id: SortOrder
}

type Film_textCountAggregate {
  _all: Int!
  description: Int!
  film_id: Int!
  title: Int!
}

input Film_textCountOrderByAggregateInput {
  description: SortOrder
  film_id: SortOrder
  title: SortOrder
}

input Film_textCreateInput {
  description: String
  film_id: Int!
  title: String!
}

input Film_textCreateManyInput {
  description: String
  film_id: Int!
  title: String!
}

type Film_textGroupBy {
  _avg: Film_textAvgAggregate
  _count: Film_textCountAggregate
  _max: Film_textMaxAggregate
  _min: Film_textMinAggregate
  _sum: Film_textSumAggregate
  description: String
  film_id: Int!
  title: String!
}

type Film_textMaxAggregate {
  description: String
  film_id: Int
  title: String
}

input Film_textMaxOrderByAggregateInput {
  description: SortOrder
  film_id: SortOrder
  title: SortOrder
}

type Film_textMinAggregate {
  description: String
  film_id: Int
  title: String
}

input Film_textMinOrderByAggregateInput {
  description: SortOrder
  film_id: SortOrder
  title: SortOrder
}

input Film_textOrderByWithAggregationInput {
  _avg: Film_textAvgOrderByAggregateInput
  _count: Film_textCountOrderByAggregateInput
  _max: Film_textMaxOrderByAggregateInput
  _min: Film_textMinOrderByAggregateInput
  _sum: Film_textSumOrderByAggregateInput
  description: SortOrderInput
  film_id: SortOrder
  title: SortOrder
}

input Film_textOrderByWithRelationInput {
  description: SortOrderInput
  film_id: SortOrder
  title: SortOrder
}

enum Film_textScalarFieldEnum {
  description
  film_id
  title
}

input Film_textScalarWhereWithAggregatesInput {
  AND: [Film_textScalarWhereWithAggregatesInput!]
  NOT: [Film_textScalarWhereWithAggregatesInput!]
  OR: [Film_textScalarWhereWithAggregatesInput!]
  description: StringNullableWithAggregatesFilter
  film_id: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
}

type Film_textSumAggregate {
  film_id: Int
}

input Film_textSumOrderByAggregateInput {
  film_id: SortOrder
}

input Film_textUpdateInput {
  description: NullableStringFieldUpdateOperationsInput
  film_id: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input Film_textUpdateManyMutationInput {
  description: NullableStringFieldUpdateOperationsInput
  film_id: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input Film_textWhereInput {
  AND: [Film_textWhereInput!]
  NOT: [Film_textWhereInput!]
  OR: [Film_textWhereInput!]
  description: StringNullableFilter
  film_id: IntFilter
  title: StringFilter
}

input Film_textWhereUniqueInput {
  AND: [Film_textWhereInput!]
  NOT: [Film_textWhereInput!]
  OR: [Film_textWhereInput!]
  description: StringNullableFilter
  film_id: Int
  title: StringFilter
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Inventory {
  _count: InventoryCount
  film: Film!
  film_id: Int!
  inventory_id: Int!
  last_update: DateTimeISO!
  rental(cursor: RentalWhereUniqueInput, distinct: [RentalScalarFieldEnum!], orderBy: [RentalOrderByWithRelationInput!], skip: Int, take: Int, where: RentalWhereInput): [Rental!]!
  store: Store!
  store_id: Int!
}

type InventoryAvgAggregate {
  film_id: Float
  inventory_id: Float
  store_id: Float
}

input InventoryAvgOrderByAggregateInput {
  film_id: SortOrder
  inventory_id: SortOrder
  store_id: SortOrder
}

type InventoryCount {
  rental(where: RentalWhereInput): Int!
}

type InventoryCountAggregate {
  _all: Int!
  film_id: Int!
  inventory_id: Int!
  last_update: Int!
  store_id: Int!
}

input InventoryCountOrderByAggregateInput {
  film_id: SortOrder
  inventory_id: SortOrder
  last_update: SortOrder
  store_id: SortOrder
}

input InventoryCreateInput {
  film: FilmCreateNestedOneWithoutInventoryInput!
  last_update: DateTimeISO
  rental: RentalCreateNestedManyWithoutInventoryInput
  store: StoreCreateNestedOneWithoutInventoryInput!
}

input InventoryCreateManyFilmInput {
  inventory_id: Int
  last_update: DateTimeISO
  store_id: Int!
}

input InventoryCreateManyFilmInputEnvelope {
  data: [InventoryCreateManyFilmInput!]!
  skipDuplicates: Boolean
}

input InventoryCreateManyInput {
  film_id: Int!
  inventory_id: Int
  last_update: DateTimeISO
  store_id: Int!
}

input InventoryCreateManyStoreInput {
  film_id: Int!
  inventory_id: Int
  last_update: DateTimeISO
}

input InventoryCreateManyStoreInputEnvelope {
  data: [InventoryCreateManyStoreInput!]!
  skipDuplicates: Boolean
}

input InventoryCreateNestedManyWithoutFilmInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutFilmInput!]
  create: [InventoryCreateWithoutFilmInput!]
  createMany: InventoryCreateManyFilmInputEnvelope
}

input InventoryCreateNestedManyWithoutStoreInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutStoreInput!]
  create: [InventoryCreateWithoutStoreInput!]
  createMany: InventoryCreateManyStoreInputEnvelope
}

input InventoryCreateNestedOneWithoutRentalInput {
  connect: InventoryWhereUniqueInput
  connectOrCreate: InventoryCreateOrConnectWithoutRentalInput
  create: InventoryCreateWithoutRentalInput
}

input InventoryCreateOrConnectWithoutFilmInput {
  create: InventoryCreateWithoutFilmInput!
  where: InventoryWhereUniqueInput!
}

input InventoryCreateOrConnectWithoutRentalInput {
  create: InventoryCreateWithoutRentalInput!
  where: InventoryWhereUniqueInput!
}

input InventoryCreateOrConnectWithoutStoreInput {
  create: InventoryCreateWithoutStoreInput!
  where: InventoryWhereUniqueInput!
}

input InventoryCreateWithoutFilmInput {
  last_update: DateTimeISO
  rental: RentalCreateNestedManyWithoutInventoryInput
  store: StoreCreateNestedOneWithoutInventoryInput!
}

input InventoryCreateWithoutRentalInput {
  film: FilmCreateNestedOneWithoutInventoryInput!
  last_update: DateTimeISO
  store: StoreCreateNestedOneWithoutInventoryInput!
}

input InventoryCreateWithoutStoreInput {
  film: FilmCreateNestedOneWithoutInventoryInput!
  last_update: DateTimeISO
  rental: RentalCreateNestedManyWithoutInventoryInput
}

type InventoryGroupBy {
  _avg: InventoryAvgAggregate
  _count: InventoryCountAggregate
  _max: InventoryMaxAggregate
  _min: InventoryMinAggregate
  _sum: InventorySumAggregate
  film_id: Int!
  inventory_id: Int!
  last_update: DateTimeISO!
  store_id: Int!
}

input InventoryListRelationFilter {
  every: InventoryWhereInput
  none: InventoryWhereInput
  some: InventoryWhereInput
}

type InventoryMaxAggregate {
  film_id: Int
  inventory_id: Int
  last_update: DateTimeISO
  store_id: Int
}

input InventoryMaxOrderByAggregateInput {
  film_id: SortOrder
  inventory_id: SortOrder
  last_update: SortOrder
  store_id: SortOrder
}

type InventoryMinAggregate {
  film_id: Int
  inventory_id: Int
  last_update: DateTimeISO
  store_id: Int
}

input InventoryMinOrderByAggregateInput {
  film_id: SortOrder
  inventory_id: SortOrder
  last_update: SortOrder
  store_id: SortOrder
}

input InventoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input InventoryOrderByWithAggregationInput {
  _avg: InventoryAvgOrderByAggregateInput
  _count: InventoryCountOrderByAggregateInput
  _max: InventoryMaxOrderByAggregateInput
  _min: InventoryMinOrderByAggregateInput
  _sum: InventorySumOrderByAggregateInput
  film_id: SortOrder
  inventory_id: SortOrder
  last_update: SortOrder
  store_id: SortOrder
}

input InventoryOrderByWithRelationInput {
  film: FilmOrderByWithRelationInput
  film_id: SortOrder
  inventory_id: SortOrder
  last_update: SortOrder
  rental: RentalOrderByRelationAggregateInput
  store: StoreOrderByWithRelationInput
  store_id: SortOrder
}

input InventoryRelationFilter {
  is: InventoryWhereInput
  isNot: InventoryWhereInput
}

enum InventoryScalarFieldEnum {
  film_id
  inventory_id
  last_update
  store_id
}

input InventoryScalarWhereInput {
  AND: [InventoryScalarWhereInput!]
  NOT: [InventoryScalarWhereInput!]
  OR: [InventoryScalarWhereInput!]
  film_id: IntFilter
  inventory_id: IntFilter
  last_update: DateTimeFilter
  store_id: IntFilter
}

input InventoryScalarWhereWithAggregatesInput {
  AND: [InventoryScalarWhereWithAggregatesInput!]
  NOT: [InventoryScalarWhereWithAggregatesInput!]
  OR: [InventoryScalarWhereWithAggregatesInput!]
  film_id: IntWithAggregatesFilter
  inventory_id: IntWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
  store_id: IntWithAggregatesFilter
}

type InventorySumAggregate {
  film_id: Int
  inventory_id: Int
  store_id: Int
}

input InventorySumOrderByAggregateInput {
  film_id: SortOrder
  inventory_id: SortOrder
  store_id: SortOrder
}

input InventoryUpdateInput {
  film: FilmUpdateOneRequiredWithoutInventoryNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  rental: RentalUpdateManyWithoutInventoryNestedInput
  store: StoreUpdateOneRequiredWithoutInventoryNestedInput
}

input InventoryUpdateManyMutationInput {
  last_update: DateTimeFieldUpdateOperationsInput
}

input InventoryUpdateManyWithWhereWithoutFilmInput {
  data: InventoryUpdateManyMutationInput!
  where: InventoryScalarWhereInput!
}

input InventoryUpdateManyWithWhereWithoutStoreInput {
  data: InventoryUpdateManyMutationInput!
  where: InventoryScalarWhereInput!
}

input InventoryUpdateManyWithoutFilmNestedInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutFilmInput!]
  create: [InventoryCreateWithoutFilmInput!]
  createMany: InventoryCreateManyFilmInputEnvelope
  delete: [InventoryWhereUniqueInput!]
  deleteMany: [InventoryScalarWhereInput!]
  disconnect: [InventoryWhereUniqueInput!]
  set: [InventoryWhereUniqueInput!]
  update: [InventoryUpdateWithWhereUniqueWithoutFilmInput!]
  updateMany: [InventoryUpdateManyWithWhereWithoutFilmInput!]
  upsert: [InventoryUpsertWithWhereUniqueWithoutFilmInput!]
}

input InventoryUpdateManyWithoutStoreNestedInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutStoreInput!]
  create: [InventoryCreateWithoutStoreInput!]
  createMany: InventoryCreateManyStoreInputEnvelope
  delete: [InventoryWhereUniqueInput!]
  deleteMany: [InventoryScalarWhereInput!]
  disconnect: [InventoryWhereUniqueInput!]
  set: [InventoryWhereUniqueInput!]
  update: [InventoryUpdateWithWhereUniqueWithoutStoreInput!]
  updateMany: [InventoryUpdateManyWithWhereWithoutStoreInput!]
  upsert: [InventoryUpsertWithWhereUniqueWithoutStoreInput!]
}

input InventoryUpdateOneRequiredWithoutRentalNestedInput {
  connect: InventoryWhereUniqueInput
  connectOrCreate: InventoryCreateOrConnectWithoutRentalInput
  create: InventoryCreateWithoutRentalInput
  update: InventoryUpdateToOneWithWhereWithoutRentalInput
  upsert: InventoryUpsertWithoutRentalInput
}

input InventoryUpdateToOneWithWhereWithoutRentalInput {
  data: InventoryUpdateWithoutRentalInput!
  where: InventoryWhereInput
}

input InventoryUpdateWithWhereUniqueWithoutFilmInput {
  data: InventoryUpdateWithoutFilmInput!
  where: InventoryWhereUniqueInput!
}

input InventoryUpdateWithWhereUniqueWithoutStoreInput {
  data: InventoryUpdateWithoutStoreInput!
  where: InventoryWhereUniqueInput!
}

input InventoryUpdateWithoutFilmInput {
  last_update: DateTimeFieldUpdateOperationsInput
  rental: RentalUpdateManyWithoutInventoryNestedInput
  store: StoreUpdateOneRequiredWithoutInventoryNestedInput
}

input InventoryUpdateWithoutRentalInput {
  film: FilmUpdateOneRequiredWithoutInventoryNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  store: StoreUpdateOneRequiredWithoutInventoryNestedInput
}

input InventoryUpdateWithoutStoreInput {
  film: FilmUpdateOneRequiredWithoutInventoryNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  rental: RentalUpdateManyWithoutInventoryNestedInput
}

input InventoryUpsertWithWhereUniqueWithoutFilmInput {
  create: InventoryCreateWithoutFilmInput!
  update: InventoryUpdateWithoutFilmInput!
  where: InventoryWhereUniqueInput!
}

input InventoryUpsertWithWhereUniqueWithoutStoreInput {
  create: InventoryCreateWithoutStoreInput!
  update: InventoryUpdateWithoutStoreInput!
  where: InventoryWhereUniqueInput!
}

input InventoryUpsertWithoutRentalInput {
  create: InventoryCreateWithoutRentalInput!
  update: InventoryUpdateWithoutRentalInput!
  where: InventoryWhereInput
}

input InventoryWhereInput {
  AND: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  film: FilmRelationFilter
  film_id: IntFilter
  inventory_id: IntFilter
  last_update: DateTimeFilter
  rental: RentalListRelationFilter
  store: StoreRelationFilter
  store_id: IntFilter
}

input InventoryWhereUniqueInput {
  AND: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  film: FilmRelationFilter
  film_id: IntFilter
  inventory_id: Int
  last_update: DateTimeFilter
  rental: RentalListRelationFilter
  store: StoreRelationFilter
  store_id: IntFilter
}

type Language {
  _count: LanguageCount
  film_film_language_idTolanguage(cursor: FilmWhereUniqueInput, distinct: [FilmScalarFieldEnum!], orderBy: [FilmOrderByWithRelationInput!], skip: Int, take: Int, where: FilmWhereInput): [Film!]!
  film_film_original_language_idTolanguage(cursor: FilmWhereUniqueInput, distinct: [FilmScalarFieldEnum!], orderBy: [FilmOrderByWithRelationInput!], skip: Int, take: Int, where: FilmWhereInput): [Film!]!
  language_id: Int!
  last_update: DateTimeISO!
  name: String!
}

type LanguageAvgAggregate {
  language_id: Float
}

input LanguageAvgOrderByAggregateInput {
  language_id: SortOrder
}

type LanguageCount {
  film_film_language_idTolanguage(where: FilmWhereInput): Int!
  film_film_original_language_idTolanguage(where: FilmWhereInput): Int!
}

type LanguageCountAggregate {
  _all: Int!
  language_id: Int!
  last_update: Int!
  name: Int!
}

input LanguageCountOrderByAggregateInput {
  language_id: SortOrder
  last_update: SortOrder
  name: SortOrder
}

input LanguageCreateInput {
  film_film_language_idTolanguage: FilmCreateNestedManyWithoutLanguage_film_language_idTolanguageInput
  film_film_original_language_idTolanguage: FilmCreateNestedManyWithoutLanguage_film_original_language_idTolanguageInput
  last_update: DateTimeISO
  name: String!
}

input LanguageCreateManyInput {
  language_id: Int
  last_update: DateTimeISO
  name: String!
}

input LanguageCreateNestedOneWithoutFilm_film_language_idTolanguageInput {
  connect: LanguageWhereUniqueInput
  connectOrCreate: LanguageCreateOrConnectWithoutFilm_film_language_idTolanguageInput
  create: LanguageCreateWithoutFilm_film_language_idTolanguageInput
}

input LanguageCreateNestedOneWithoutFilm_film_original_language_idTolanguageInput {
  connect: LanguageWhereUniqueInput
  connectOrCreate: LanguageCreateOrConnectWithoutFilm_film_original_language_idTolanguageInput
  create: LanguageCreateWithoutFilm_film_original_language_idTolanguageInput
}

input LanguageCreateOrConnectWithoutFilm_film_language_idTolanguageInput {
  create: LanguageCreateWithoutFilm_film_language_idTolanguageInput!
  where: LanguageWhereUniqueInput!
}

input LanguageCreateOrConnectWithoutFilm_film_original_language_idTolanguageInput {
  create: LanguageCreateWithoutFilm_film_original_language_idTolanguageInput!
  where: LanguageWhereUniqueInput!
}

input LanguageCreateWithoutFilm_film_language_idTolanguageInput {
  film_film_original_language_idTolanguage: FilmCreateNestedManyWithoutLanguage_film_original_language_idTolanguageInput
  last_update: DateTimeISO
  name: String!
}

input LanguageCreateWithoutFilm_film_original_language_idTolanguageInput {
  film_film_language_idTolanguage: FilmCreateNestedManyWithoutLanguage_film_language_idTolanguageInput
  last_update: DateTimeISO
  name: String!
}

type LanguageGroupBy {
  _avg: LanguageAvgAggregate
  _count: LanguageCountAggregate
  _max: LanguageMaxAggregate
  _min: LanguageMinAggregate
  _sum: LanguageSumAggregate
  language_id: Int!
  last_update: DateTimeISO!
  name: String!
}

type LanguageMaxAggregate {
  language_id: Int
  last_update: DateTimeISO
  name: String
}

input LanguageMaxOrderByAggregateInput {
  language_id: SortOrder
  last_update: SortOrder
  name: SortOrder
}

type LanguageMinAggregate {
  language_id: Int
  last_update: DateTimeISO
  name: String
}

input LanguageMinOrderByAggregateInput {
  language_id: SortOrder
  last_update: SortOrder
  name: SortOrder
}

input LanguageNullableRelationFilter {
  is: LanguageWhereInput
  isNot: LanguageWhereInput
}

input LanguageOrderByWithAggregationInput {
  _avg: LanguageAvgOrderByAggregateInput
  _count: LanguageCountOrderByAggregateInput
  _max: LanguageMaxOrderByAggregateInput
  _min: LanguageMinOrderByAggregateInput
  _sum: LanguageSumOrderByAggregateInput
  language_id: SortOrder
  last_update: SortOrder
  name: SortOrder
}

input LanguageOrderByWithRelationInput {
  film_film_language_idTolanguage: FilmOrderByRelationAggregateInput
  film_film_original_language_idTolanguage: FilmOrderByRelationAggregateInput
  language_id: SortOrder
  last_update: SortOrder
  name: SortOrder
}

input LanguageRelationFilter {
  is: LanguageWhereInput
  isNot: LanguageWhereInput
}

enum LanguageScalarFieldEnum {
  language_id
  last_update
  name
}

input LanguageScalarWhereWithAggregatesInput {
  AND: [LanguageScalarWhereWithAggregatesInput!]
  NOT: [LanguageScalarWhereWithAggregatesInput!]
  OR: [LanguageScalarWhereWithAggregatesInput!]
  language_id: IntWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type LanguageSumAggregate {
  language_id: Int
}

input LanguageSumOrderByAggregateInput {
  language_id: SortOrder
}

input LanguageUpdateInput {
  film_film_language_idTolanguage: FilmUpdateManyWithoutLanguage_film_language_idTolanguageNestedInput
  film_film_original_language_idTolanguage: FilmUpdateManyWithoutLanguage_film_original_language_idTolanguageNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input LanguageUpdateManyMutationInput {
  last_update: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input LanguageUpdateOneRequiredWithoutFilm_film_language_idTolanguageNestedInput {
  connect: LanguageWhereUniqueInput
  connectOrCreate: LanguageCreateOrConnectWithoutFilm_film_language_idTolanguageInput
  create: LanguageCreateWithoutFilm_film_language_idTolanguageInput
  update: LanguageUpdateToOneWithWhereWithoutFilm_film_language_idTolanguageInput
  upsert: LanguageUpsertWithoutFilm_film_language_idTolanguageInput
}

input LanguageUpdateOneWithoutFilm_film_original_language_idTolanguageNestedInput {
  connect: LanguageWhereUniqueInput
  connectOrCreate: LanguageCreateOrConnectWithoutFilm_film_original_language_idTolanguageInput
  create: LanguageCreateWithoutFilm_film_original_language_idTolanguageInput
  delete: LanguageWhereInput
  disconnect: LanguageWhereInput
  update: LanguageUpdateToOneWithWhereWithoutFilm_film_original_language_idTolanguageInput
  upsert: LanguageUpsertWithoutFilm_film_original_language_idTolanguageInput
}

input LanguageUpdateToOneWithWhereWithoutFilm_film_language_idTolanguageInput {
  data: LanguageUpdateWithoutFilm_film_language_idTolanguageInput!
  where: LanguageWhereInput
}

input LanguageUpdateToOneWithWhereWithoutFilm_film_original_language_idTolanguageInput {
  data: LanguageUpdateWithoutFilm_film_original_language_idTolanguageInput!
  where: LanguageWhereInput
}

input LanguageUpdateWithoutFilm_film_language_idTolanguageInput {
  film_film_original_language_idTolanguage: FilmUpdateManyWithoutLanguage_film_original_language_idTolanguageNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input LanguageUpdateWithoutFilm_film_original_language_idTolanguageInput {
  film_film_language_idTolanguage: FilmUpdateManyWithoutLanguage_film_language_idTolanguageNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input LanguageUpsertWithoutFilm_film_language_idTolanguageInput {
  create: LanguageCreateWithoutFilm_film_language_idTolanguageInput!
  update: LanguageUpdateWithoutFilm_film_language_idTolanguageInput!
  where: LanguageWhereInput
}

input LanguageUpsertWithoutFilm_film_original_language_idTolanguageInput {
  create: LanguageCreateWithoutFilm_film_original_language_idTolanguageInput!
  update: LanguageUpdateWithoutFilm_film_original_language_idTolanguageInput!
  where: LanguageWhereInput
}

input LanguageWhereInput {
  AND: [LanguageWhereInput!]
  NOT: [LanguageWhereInput!]
  OR: [LanguageWhereInput!]
  film_film_language_idTolanguage: FilmListRelationFilter
  film_film_original_language_idTolanguage: FilmListRelationFilter
  language_id: IntFilter
  last_update: DateTimeFilter
  name: StringFilter
}

input LanguageWhereUniqueInput {
  AND: [LanguageWhereInput!]
  NOT: [LanguageWhereInput!]
  OR: [LanguageWhereInput!]
  film_film_language_idTolanguage: FilmListRelationFilter
  film_film_original_language_idTolanguage: FilmListRelationFilter
  language_id: Int
  last_update: DateTimeFilter
  name: StringFilter
}

type Mutation {
  createManyActor(data: [ActorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCategory(data: [CategoryCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCity(data: [CityCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCountry(data: [CountryCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCustomer(data: [CustomerCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyFilm(data: [FilmCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyFilm_actor(data: [Film_actorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyFilm_category(data: [Film_categoryCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyFilm_text(data: [Film_textCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyInventory(data: [InventoryCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyLanguage(data: [LanguageCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPayment(data: [PaymentCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyRental(data: [RentalCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyStaff(data: [StaffCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyStore(data: [StoreCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneActor(data: ActorCreateInput!): Actor!
  createOneCategory(data: CategoryCreateInput!): Category!
  createOneCity(data: CityCreateInput!): City!
  createOneCountry(data: CountryCreateInput!): Country!
  createOneCustomer(data: CustomerCreateInput!): Customer!
  createOneFilm(data: FilmCreateInput!): Film!
  createOneFilm_actor(data: Film_actorCreateInput!): Film_actor!
  createOneFilm_category(data: Film_categoryCreateInput!): Film_category!
  createOneFilm_text(data: Film_textCreateInput!): Film_text!
  createOneInventory(data: InventoryCreateInput!): Inventory!
  createOneLanguage(data: LanguageCreateInput!): Language!
  createOnePayment(data: PaymentCreateInput!): Payment!
  createOneRental(data: RentalCreateInput!): Rental!
  createOneStaff(data: StaffCreateInput!): Staff!
  createOneStore(data: StoreCreateInput!): Store!
  deleteManyActor(where: ActorWhereInput): AffectedRowsOutput!
  deleteManyAddress(where: AddressWhereInput): AffectedRowsOutput!
  deleteManyCategory(where: CategoryWhereInput): AffectedRowsOutput!
  deleteManyCity(where: CityWhereInput): AffectedRowsOutput!
  deleteManyCountry(where: CountryWhereInput): AffectedRowsOutput!
  deleteManyCustomer(where: CustomerWhereInput): AffectedRowsOutput!
  deleteManyFilm(where: FilmWhereInput): AffectedRowsOutput!
  deleteManyFilm_actor(where: Film_actorWhereInput): AffectedRowsOutput!
  deleteManyFilm_category(where: Film_categoryWhereInput): AffectedRowsOutput!
  deleteManyFilm_text(where: Film_textWhereInput): AffectedRowsOutput!
  deleteManyInventory(where: InventoryWhereInput): AffectedRowsOutput!
  deleteManyLanguage(where: LanguageWhereInput): AffectedRowsOutput!
  deleteManyPayment(where: PaymentWhereInput): AffectedRowsOutput!
  deleteManyRental(where: RentalWhereInput): AffectedRowsOutput!
  deleteManyStaff(where: StaffWhereInput): AffectedRowsOutput!
  deleteManyStore(where: StoreWhereInput): AffectedRowsOutput!
  deleteOneActor(where: ActorWhereUniqueInput!): Actor
  deleteOneAddress(where: AddressWhereUniqueInput!): Address
  deleteOneCategory(where: CategoryWhereUniqueInput!): Category
  deleteOneCity(where: CityWhereUniqueInput!): City
  deleteOneCountry(where: CountryWhereUniqueInput!): Country
  deleteOneCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteOneFilm(where: FilmWhereUniqueInput!): Film
  deleteOneFilm_actor(where: Film_actorWhereUniqueInput!): Film_actor
  deleteOneFilm_category(where: Film_categoryWhereUniqueInput!): Film_category
  deleteOneFilm_text(where: Film_textWhereUniqueInput!): Film_text
  deleteOneInventory(where: InventoryWhereUniqueInput!): Inventory
  deleteOneLanguage(where: LanguageWhereUniqueInput!): Language
  deleteOnePayment(where: PaymentWhereUniqueInput!): Payment
  deleteOneRental(where: RentalWhereUniqueInput!): Rental
  deleteOneStaff(where: StaffWhereUniqueInput!): Staff
  deleteOneStore(where: StoreWhereUniqueInput!): Store
  updateManyActor(data: ActorUpdateManyMutationInput!, where: ActorWhereInput): AffectedRowsOutput!
  updateManyAddress(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): AffectedRowsOutput!
  updateManyCategory(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): AffectedRowsOutput!
  updateManyCity(data: CityUpdateManyMutationInput!, where: CityWhereInput): AffectedRowsOutput!
  updateManyCountry(data: CountryUpdateManyMutationInput!, where: CountryWhereInput): AffectedRowsOutput!
  updateManyCustomer(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): AffectedRowsOutput!
  updateManyFilm(data: FilmUpdateManyMutationInput!, where: FilmWhereInput): AffectedRowsOutput!
  updateManyFilm_actor(data: Film_actorUpdateManyMutationInput!, where: Film_actorWhereInput): AffectedRowsOutput!
  updateManyFilm_category(data: Film_categoryUpdateManyMutationInput!, where: Film_categoryWhereInput): AffectedRowsOutput!
  updateManyFilm_text(data: Film_textUpdateManyMutationInput!, where: Film_textWhereInput): AffectedRowsOutput!
  updateManyInventory(data: InventoryUpdateManyMutationInput!, where: InventoryWhereInput): AffectedRowsOutput!
  updateManyLanguage(data: LanguageUpdateManyMutationInput!, where: LanguageWhereInput): AffectedRowsOutput!
  updateManyPayment(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): AffectedRowsOutput!
  updateManyRental(data: RentalUpdateManyMutationInput!, where: RentalWhereInput): AffectedRowsOutput!
  updateManyStaff(data: StaffUpdateManyMutationInput!, where: StaffWhereInput): AffectedRowsOutput!
  updateManyStore(data: StoreUpdateManyMutationInput!, where: StoreWhereInput): AffectedRowsOutput!
  updateOneActor(data: ActorUpdateInput!, where: ActorWhereUniqueInput!): Actor
  updateOneAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateOneCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateOneCity(data: CityUpdateInput!, where: CityWhereUniqueInput!): City
  updateOneCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateOneCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateOneFilm(data: FilmUpdateInput!, where: FilmWhereUniqueInput!): Film
  updateOneFilm_actor(data: Film_actorUpdateInput!, where: Film_actorWhereUniqueInput!): Film_actor
  updateOneFilm_category(data: Film_categoryUpdateInput!, where: Film_categoryWhereUniqueInput!): Film_category
  updateOneFilm_text(data: Film_textUpdateInput!, where: Film_textWhereUniqueInput!): Film_text
  updateOneInventory(data: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory
  updateOneLanguage(data: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language
  updateOnePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateOneRental(data: RentalUpdateInput!, where: RentalWhereUniqueInput!): Rental
  updateOneStaff(data: StaffUpdateInput!, where: StaffWhereUniqueInput!): Staff
  updateOneStore(data: StoreUpdateInput!, where: StoreWhereUniqueInput!): Store
  upsertOneActor(create: ActorCreateInput!, update: ActorUpdateInput!, where: ActorWhereUniqueInput!): Actor!
  upsertOneCategory(create: CategoryCreateInput!, update: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  upsertOneCity(create: CityCreateInput!, update: CityUpdateInput!, where: CityWhereUniqueInput!): City!
  upsertOneCountry(create: CountryCreateInput!, update: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country!
  upsertOneCustomer(create: CustomerCreateInput!, update: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer!
  upsertOneFilm(create: FilmCreateInput!, update: FilmUpdateInput!, where: FilmWhereUniqueInput!): Film!
  upsertOneFilm_actor(create: Film_actorCreateInput!, update: Film_actorUpdateInput!, where: Film_actorWhereUniqueInput!): Film_actor!
  upsertOneFilm_category(create: Film_categoryCreateInput!, update: Film_categoryUpdateInput!, where: Film_categoryWhereUniqueInput!): Film_category!
  upsertOneFilm_text(create: Film_textCreateInput!, update: Film_textUpdateInput!, where: Film_textWhereUniqueInput!): Film_text!
  upsertOneInventory(create: InventoryCreateInput!, update: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory!
  upsertOneLanguage(create: LanguageCreateInput!, update: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language!
  upsertOnePayment(create: PaymentCreateInput!, update: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment!
  upsertOneRental(create: RentalCreateInput!, update: RentalUpdateInput!, where: RentalWhereUniqueInput!): Rental!
  upsertOneStaff(create: StaffCreateInput!, update: StaffUpdateInput!, where: StaffWhereUniqueInput!): Staff!
  upsertOneStore(create: StoreCreateInput!, update: StoreUpdateInput!, where: StoreWhereUniqueInput!): Store!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedBytesNullableFilter {
  equals: Byte
  in: [Byte!]
  not: NestedBytesNullableFilter
  notIn: [Byte!]
}

input NestedBytesNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBytesNullableFilter
  _min: NestedBytesNullableFilter
  equals: Byte
  in: [Byte!]
  not: NestedBytesNullableWithAggregatesFilter
  notIn: [Byte!]
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedDecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input NestedDecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedEnumfilm_ratingNullableFilter {
  equals: film_rating
  in: [film_rating!]
  not: NestedEnumfilm_ratingNullableFilter
  notIn: [film_rating!]
}

input NestedEnumfilm_ratingNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumfilm_ratingNullableFilter
  _min: NestedEnumfilm_ratingNullableFilter
  equals: film_rating
  in: [film_rating!]
  not: NestedEnumfilm_ratingNullableWithAggregatesFilter
  notIn: [film_rating!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableBytesFieldUpdateOperationsInput {
  set: Byte
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTimeISO
}

input NullableEnumfilm_ratingFieldUpdateOperationsInput {
  set: film_rating
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

type Payment {
  amount: Decimal!
  customer: Customer!
  customer_id: Int!
  last_update: DateTimeISO
  payment_date: DateTimeISO!
  payment_id: Int!
  rental(where: RentalWhereInput): Rental
  rental_id: Int
  staff: Staff!
  staff_id: Int!
}

type PaymentAvgAggregate {
  amount: Decimal
  customer_id: Float
  payment_id: Float
  rental_id: Float
  staff_id: Float
}

input PaymentAvgOrderByAggregateInput {
  amount: SortOrder
  customer_id: SortOrder
  payment_id: SortOrder
  rental_id: SortOrder
  staff_id: SortOrder
}

type PaymentCountAggregate {
  _all: Int!
  amount: Int!
  customer_id: Int!
  last_update: Int!
  payment_date: Int!
  payment_id: Int!
  rental_id: Int!
  staff_id: Int!
}

input PaymentCountOrderByAggregateInput {
  amount: SortOrder
  customer_id: SortOrder
  last_update: SortOrder
  payment_date: SortOrder
  payment_id: SortOrder
  rental_id: SortOrder
  staff_id: SortOrder
}

input PaymentCreateInput {
  amount: Decimal!
  customer: CustomerCreateNestedOneWithoutPaymentInput!
  last_update: DateTimeISO
  payment_date: DateTimeISO!
  rental: RentalCreateNestedOneWithoutPaymentInput
  staff: StaffCreateNestedOneWithoutPaymentInput!
}

input PaymentCreateManyCustomerInput {
  amount: Decimal!
  last_update: DateTimeISO
  payment_date: DateTimeISO!
  payment_id: Int
  rental_id: Int
  staff_id: Int!
}

input PaymentCreateManyCustomerInputEnvelope {
  data: [PaymentCreateManyCustomerInput!]!
  skipDuplicates: Boolean
}

input PaymentCreateManyInput {
  amount: Decimal!
  customer_id: Int!
  last_update: DateTimeISO
  payment_date: DateTimeISO!
  payment_id: Int
  rental_id: Int
  staff_id: Int!
}

input PaymentCreateManyRentalInput {
  amount: Decimal!
  customer_id: Int!
  last_update: DateTimeISO
  payment_date: DateTimeISO!
  payment_id: Int
  staff_id: Int!
}

input PaymentCreateManyRentalInputEnvelope {
  data: [PaymentCreateManyRentalInput!]!
  skipDuplicates: Boolean
}

input PaymentCreateManyStaffInput {
  amount: Decimal!
  customer_id: Int!
  last_update: DateTimeISO
  payment_date: DateTimeISO!
  payment_id: Int
  rental_id: Int
}

input PaymentCreateManyStaffInputEnvelope {
  data: [PaymentCreateManyStaffInput!]!
  skipDuplicates: Boolean
}

input PaymentCreateNestedManyWithoutCustomerInput {
  connect: [PaymentWhereUniqueInput!]
  connectOrCreate: [PaymentCreateOrConnectWithoutCustomerInput!]
  create: [PaymentCreateWithoutCustomerInput!]
  createMany: PaymentCreateManyCustomerInputEnvelope
}

input PaymentCreateNestedManyWithoutRentalInput {
  connect: [PaymentWhereUniqueInput!]
  connectOrCreate: [PaymentCreateOrConnectWithoutRentalInput!]
  create: [PaymentCreateWithoutRentalInput!]
  createMany: PaymentCreateManyRentalInputEnvelope
}

input PaymentCreateNestedManyWithoutStaffInput {
  connect: [PaymentWhereUniqueInput!]
  connectOrCreate: [PaymentCreateOrConnectWithoutStaffInput!]
  create: [PaymentCreateWithoutStaffInput!]
  createMany: PaymentCreateManyStaffInputEnvelope
}

input PaymentCreateOrConnectWithoutCustomerInput {
  create: PaymentCreateWithoutCustomerInput!
  where: PaymentWhereUniqueInput!
}

input PaymentCreateOrConnectWithoutRentalInput {
  create: PaymentCreateWithoutRentalInput!
  where: PaymentWhereUniqueInput!
}

input PaymentCreateOrConnectWithoutStaffInput {
  create: PaymentCreateWithoutStaffInput!
  where: PaymentWhereUniqueInput!
}

input PaymentCreateWithoutCustomerInput {
  amount: Decimal!
  last_update: DateTimeISO
  payment_date: DateTimeISO!
  rental: RentalCreateNestedOneWithoutPaymentInput
  staff: StaffCreateNestedOneWithoutPaymentInput!
}

input PaymentCreateWithoutRentalInput {
  amount: Decimal!
  customer: CustomerCreateNestedOneWithoutPaymentInput!
  last_update: DateTimeISO
  payment_date: DateTimeISO!
  staff: StaffCreateNestedOneWithoutPaymentInput!
}

input PaymentCreateWithoutStaffInput {
  amount: Decimal!
  customer: CustomerCreateNestedOneWithoutPaymentInput!
  last_update: DateTimeISO
  payment_date: DateTimeISO!
  rental: RentalCreateNestedOneWithoutPaymentInput
}

type PaymentGroupBy {
  _avg: PaymentAvgAggregate
  _count: PaymentCountAggregate
  _max: PaymentMaxAggregate
  _min: PaymentMinAggregate
  _sum: PaymentSumAggregate
  amount: Decimal!
  customer_id: Int!
  last_update: DateTimeISO
  payment_date: DateTimeISO!
  payment_id: Int!
  rental_id: Int
  staff_id: Int!
}

input PaymentListRelationFilter {
  every: PaymentWhereInput
  none: PaymentWhereInput
  some: PaymentWhereInput
}

type PaymentMaxAggregate {
  amount: Decimal
  customer_id: Int
  last_update: DateTimeISO
  payment_date: DateTimeISO
  payment_id: Int
  rental_id: Int
  staff_id: Int
}

input PaymentMaxOrderByAggregateInput {
  amount: SortOrder
  customer_id: SortOrder
  last_update: SortOrder
  payment_date: SortOrder
  payment_id: SortOrder
  rental_id: SortOrder
  staff_id: SortOrder
}

type PaymentMinAggregate {
  amount: Decimal
  customer_id: Int
  last_update: DateTimeISO
  payment_date: DateTimeISO
  payment_id: Int
  rental_id: Int
  staff_id: Int
}

input PaymentMinOrderByAggregateInput {
  amount: SortOrder
  customer_id: SortOrder
  last_update: SortOrder
  payment_date: SortOrder
  payment_id: SortOrder
  rental_id: SortOrder
  staff_id: SortOrder
}

input PaymentOrderByRelationAggregateInput {
  _count: SortOrder
}

input PaymentOrderByWithAggregationInput {
  _avg: PaymentAvgOrderByAggregateInput
  _count: PaymentCountOrderByAggregateInput
  _max: PaymentMaxOrderByAggregateInput
  _min: PaymentMinOrderByAggregateInput
  _sum: PaymentSumOrderByAggregateInput
  amount: SortOrder
  customer_id: SortOrder
  last_update: SortOrderInput
  payment_date: SortOrder
  payment_id: SortOrder
  rental_id: SortOrderInput
  staff_id: SortOrder
}

input PaymentOrderByWithRelationInput {
  amount: SortOrder
  customer: CustomerOrderByWithRelationInput
  customer_id: SortOrder
  last_update: SortOrderInput
  payment_date: SortOrder
  payment_id: SortOrder
  rental: RentalOrderByWithRelationInput
  rental_id: SortOrderInput
  staff: StaffOrderByWithRelationInput
  staff_id: SortOrder
}

enum PaymentScalarFieldEnum {
  amount
  customer_id
  last_update
  payment_date
  payment_id
  rental_id
  staff_id
}

input PaymentScalarWhereInput {
  AND: [PaymentScalarWhereInput!]
  NOT: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  amount: DecimalFilter
  customer_id: IntFilter
  last_update: DateTimeNullableFilter
  payment_date: DateTimeFilter
  payment_id: IntFilter
  rental_id: IntNullableFilter
  staff_id: IntFilter
}

input PaymentScalarWhereWithAggregatesInput {
  AND: [PaymentScalarWhereWithAggregatesInput!]
  NOT: [PaymentScalarWhereWithAggregatesInput!]
  OR: [PaymentScalarWhereWithAggregatesInput!]
  amount: DecimalWithAggregatesFilter
  customer_id: IntWithAggregatesFilter
  last_update: DateTimeNullableWithAggregatesFilter
  payment_date: DateTimeWithAggregatesFilter
  payment_id: IntWithAggregatesFilter
  rental_id: IntNullableWithAggregatesFilter
  staff_id: IntWithAggregatesFilter
}

type PaymentSumAggregate {
  amount: Decimal
  customer_id: Int
  payment_id: Int
  rental_id: Int
  staff_id: Int
}

input PaymentSumOrderByAggregateInput {
  amount: SortOrder
  customer_id: SortOrder
  payment_id: SortOrder
  rental_id: SortOrder
  staff_id: SortOrder
}

input PaymentUpdateInput {
  amount: DecimalFieldUpdateOperationsInput
  customer: CustomerUpdateOneRequiredWithoutPaymentNestedInput
  last_update: NullableDateTimeFieldUpdateOperationsInput
  payment_date: DateTimeFieldUpdateOperationsInput
  rental: RentalUpdateOneWithoutPaymentNestedInput
  staff: StaffUpdateOneRequiredWithoutPaymentNestedInput
}

input PaymentUpdateManyMutationInput {
  amount: DecimalFieldUpdateOperationsInput
  last_update: NullableDateTimeFieldUpdateOperationsInput
  payment_date: DateTimeFieldUpdateOperationsInput
}

input PaymentUpdateManyWithWhereWithoutCustomerInput {
  data: PaymentUpdateManyMutationInput!
  where: PaymentScalarWhereInput!
}

input PaymentUpdateManyWithWhereWithoutRentalInput {
  data: PaymentUpdateManyMutationInput!
  where: PaymentScalarWhereInput!
}

input PaymentUpdateManyWithWhereWithoutStaffInput {
  data: PaymentUpdateManyMutationInput!
  where: PaymentScalarWhereInput!
}

input PaymentUpdateManyWithoutCustomerNestedInput {
  connect: [PaymentWhereUniqueInput!]
  connectOrCreate: [PaymentCreateOrConnectWithoutCustomerInput!]
  create: [PaymentCreateWithoutCustomerInput!]
  createMany: PaymentCreateManyCustomerInputEnvelope
  delete: [PaymentWhereUniqueInput!]
  deleteMany: [PaymentScalarWhereInput!]
  disconnect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [PaymentUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutCustomerInput!]
}

input PaymentUpdateManyWithoutRentalNestedInput {
  connect: [PaymentWhereUniqueInput!]
  connectOrCreate: [PaymentCreateOrConnectWithoutRentalInput!]
  create: [PaymentCreateWithoutRentalInput!]
  createMany: PaymentCreateManyRentalInputEnvelope
  delete: [PaymentWhereUniqueInput!]
  deleteMany: [PaymentScalarWhereInput!]
  disconnect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutRentalInput!]
  updateMany: [PaymentUpdateManyWithWhereWithoutRentalInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutRentalInput!]
}

input PaymentUpdateManyWithoutStaffNestedInput {
  connect: [PaymentWhereUniqueInput!]
  connectOrCreate: [PaymentCreateOrConnectWithoutStaffInput!]
  create: [PaymentCreateWithoutStaffInput!]
  createMany: PaymentCreateManyStaffInputEnvelope
  delete: [PaymentWhereUniqueInput!]
  deleteMany: [PaymentScalarWhereInput!]
  disconnect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutStaffInput!]
  updateMany: [PaymentUpdateManyWithWhereWithoutStaffInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutStaffInput!]
}

input PaymentUpdateWithWhereUniqueWithoutCustomerInput {
  data: PaymentUpdateWithoutCustomerInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpdateWithWhereUniqueWithoutRentalInput {
  data: PaymentUpdateWithoutRentalInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpdateWithWhereUniqueWithoutStaffInput {
  data: PaymentUpdateWithoutStaffInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpdateWithoutCustomerInput {
  amount: DecimalFieldUpdateOperationsInput
  last_update: NullableDateTimeFieldUpdateOperationsInput
  payment_date: DateTimeFieldUpdateOperationsInput
  rental: RentalUpdateOneWithoutPaymentNestedInput
  staff: StaffUpdateOneRequiredWithoutPaymentNestedInput
}

input PaymentUpdateWithoutRentalInput {
  amount: DecimalFieldUpdateOperationsInput
  customer: CustomerUpdateOneRequiredWithoutPaymentNestedInput
  last_update: NullableDateTimeFieldUpdateOperationsInput
  payment_date: DateTimeFieldUpdateOperationsInput
  staff: StaffUpdateOneRequiredWithoutPaymentNestedInput
}

input PaymentUpdateWithoutStaffInput {
  amount: DecimalFieldUpdateOperationsInput
  customer: CustomerUpdateOneRequiredWithoutPaymentNestedInput
  last_update: NullableDateTimeFieldUpdateOperationsInput
  payment_date: DateTimeFieldUpdateOperationsInput
  rental: RentalUpdateOneWithoutPaymentNestedInput
}

input PaymentUpsertWithWhereUniqueWithoutCustomerInput {
  create: PaymentCreateWithoutCustomerInput!
  update: PaymentUpdateWithoutCustomerInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpsertWithWhereUniqueWithoutRentalInput {
  create: PaymentCreateWithoutRentalInput!
  update: PaymentUpdateWithoutRentalInput!
  where: PaymentWhereUniqueInput!
}

input PaymentUpsertWithWhereUniqueWithoutStaffInput {
  create: PaymentCreateWithoutStaffInput!
  update: PaymentUpdateWithoutStaffInput!
  where: PaymentWhereUniqueInput!
}

input PaymentWhereInput {
  AND: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  amount: DecimalFilter
  customer: CustomerRelationFilter
  customer_id: IntFilter
  last_update: DateTimeNullableFilter
  payment_date: DateTimeFilter
  payment_id: IntFilter
  rental: RentalNullableRelationFilter
  rental_id: IntNullableFilter
  staff: StaffRelationFilter
  staff_id: IntFilter
}

input PaymentWhereUniqueInput {
  AND: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  amount: DecimalFilter
  customer: CustomerRelationFilter
  customer_id: IntFilter
  last_update: DateTimeNullableFilter
  payment_date: DateTimeFilter
  payment_id: Int
  rental: RentalNullableRelationFilter
  rental_id: IntNullableFilter
  staff: StaffRelationFilter
  staff_id: IntFilter
}

type Query {
  actor(where: ActorWhereUniqueInput!): Actor
  actors(cursor: ActorWhereUniqueInput, distinct: [ActorScalarFieldEnum!], orderBy: [ActorOrderByWithRelationInput!], skip: Int, take: Int, where: ActorWhereInput): [Actor!]!
  address(where: AddressWhereUniqueInput!): Address
  addresses(cursor: AddressWhereUniqueInput, distinct: [AddressScalarFieldEnum!], orderBy: [AddressOrderByWithRelationInput!], skip: Int, take: Int, where: AddressWhereInput): [Address!]!
  aggregateActor(cursor: ActorWhereUniqueInput, orderBy: [ActorOrderByWithRelationInput!], skip: Int, take: Int, where: ActorWhereInput): AggregateActor!
  aggregateAddress(cursor: AddressWhereUniqueInput, orderBy: [AddressOrderByWithRelationInput!], skip: Int, take: Int, where: AddressWhereInput): AggregateAddress!
  aggregateCategory(cursor: CategoryWhereUniqueInput, orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): AggregateCategory!
  aggregateCity(cursor: CityWhereUniqueInput, orderBy: [CityOrderByWithRelationInput!], skip: Int, take: Int, where: CityWhereInput): AggregateCity!
  aggregateCountry(cursor: CountryWhereUniqueInput, orderBy: [CountryOrderByWithRelationInput!], skip: Int, take: Int, where: CountryWhereInput): AggregateCountry!
  aggregateCustomer(cursor: CustomerWhereUniqueInput, orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): AggregateCustomer!
  aggregateFilm(cursor: FilmWhereUniqueInput, orderBy: [FilmOrderByWithRelationInput!], skip: Int, take: Int, where: FilmWhereInput): AggregateFilm!
  aggregateFilm_actor(cursor: Film_actorWhereUniqueInput, orderBy: [Film_actorOrderByWithRelationInput!], skip: Int, take: Int, where: Film_actorWhereInput): AggregateFilm_actor!
  aggregateFilm_category(cursor: Film_categoryWhereUniqueInput, orderBy: [Film_categoryOrderByWithRelationInput!], skip: Int, take: Int, where: Film_categoryWhereInput): AggregateFilm_category!
  aggregateFilm_text(cursor: Film_textWhereUniqueInput, orderBy: [Film_textOrderByWithRelationInput!], skip: Int, take: Int, where: Film_textWhereInput): AggregateFilm_text!
  aggregateInventory(cursor: InventoryWhereUniqueInput, orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): AggregateInventory!
  aggregateLanguage(cursor: LanguageWhereUniqueInput, orderBy: [LanguageOrderByWithRelationInput!], skip: Int, take: Int, where: LanguageWhereInput): AggregateLanguage!
  aggregatePayment(cursor: PaymentWhereUniqueInput, orderBy: [PaymentOrderByWithRelationInput!], skip: Int, take: Int, where: PaymentWhereInput): AggregatePayment!
  aggregateRental(cursor: RentalWhereUniqueInput, orderBy: [RentalOrderByWithRelationInput!], skip: Int, take: Int, where: RentalWhereInput): AggregateRental!
  aggregateStaff(cursor: StaffWhereUniqueInput, orderBy: [StaffOrderByWithRelationInput!], skip: Int, take: Int, where: StaffWhereInput): AggregateStaff!
  aggregateStore(cursor: StoreWhereUniqueInput, orderBy: [StoreOrderByWithRelationInput!], skip: Int, take: Int, where: StoreWhereInput): AggregateStore!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  category(where: CategoryWhereUniqueInput!): Category
  cities(cursor: CityWhereUniqueInput, distinct: [CityScalarFieldEnum!], orderBy: [CityOrderByWithRelationInput!], skip: Int, take: Int, where: CityWhereInput): [City!]!
  city(where: CityWhereUniqueInput!): City
  countries(cursor: CountryWhereUniqueInput, distinct: [CountryScalarFieldEnum!], orderBy: [CountryOrderByWithRelationInput!], skip: Int, take: Int, where: CountryWhereInput): [Country!]!
  country(where: CountryWhereUniqueInput!): Country
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  film(where: FilmWhereUniqueInput!): Film
  film_actor(where: Film_actorWhereUniqueInput!): Film_actor
  film_actors(cursor: Film_actorWhereUniqueInput, distinct: [Film_actorScalarFieldEnum!], orderBy: [Film_actorOrderByWithRelationInput!], skip: Int, take: Int, where: Film_actorWhereInput): [Film_actor!]!
  film_categories(cursor: Film_categoryWhereUniqueInput, distinct: [Film_categoryScalarFieldEnum!], orderBy: [Film_categoryOrderByWithRelationInput!], skip: Int, take: Int, where: Film_categoryWhereInput): [Film_category!]!
  film_category(where: Film_categoryWhereUniqueInput!): Film_category
  film_text(where: Film_textWhereUniqueInput!): Film_text
  film_texts(cursor: Film_textWhereUniqueInput, distinct: [Film_textScalarFieldEnum!], orderBy: [Film_textOrderByWithRelationInput!], skip: Int, take: Int, where: Film_textWhereInput): [Film_text!]!
  films(cursor: FilmWhereUniqueInput, distinct: [FilmScalarFieldEnum!], orderBy: [FilmOrderByWithRelationInput!], skip: Int, take: Int, where: FilmWhereInput): [Film!]!
  findFirstActor(cursor: ActorWhereUniqueInput, distinct: [ActorScalarFieldEnum!], orderBy: [ActorOrderByWithRelationInput!], skip: Int, take: Int, where: ActorWhereInput): Actor
  findFirstActorOrThrow(cursor: ActorWhereUniqueInput, distinct: [ActorScalarFieldEnum!], orderBy: [ActorOrderByWithRelationInput!], skip: Int, take: Int, where: ActorWhereInput): Actor
  findFirstAddress(cursor: AddressWhereUniqueInput, distinct: [AddressScalarFieldEnum!], orderBy: [AddressOrderByWithRelationInput!], skip: Int, take: Int, where: AddressWhereInput): Address
  findFirstAddressOrThrow(cursor: AddressWhereUniqueInput, distinct: [AddressScalarFieldEnum!], orderBy: [AddressOrderByWithRelationInput!], skip: Int, take: Int, where: AddressWhereInput): Address
  findFirstCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstCategoryOrThrow(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstCity(cursor: CityWhereUniqueInput, distinct: [CityScalarFieldEnum!], orderBy: [CityOrderByWithRelationInput!], skip: Int, take: Int, where: CityWhereInput): City
  findFirstCityOrThrow(cursor: CityWhereUniqueInput, distinct: [CityScalarFieldEnum!], orderBy: [CityOrderByWithRelationInput!], skip: Int, take: Int, where: CityWhereInput): City
  findFirstCountry(cursor: CountryWhereUniqueInput, distinct: [CountryScalarFieldEnum!], orderBy: [CountryOrderByWithRelationInput!], skip: Int, take: Int, where: CountryWhereInput): Country
  findFirstCountryOrThrow(cursor: CountryWhereUniqueInput, distinct: [CountryScalarFieldEnum!], orderBy: [CountryOrderByWithRelationInput!], skip: Int, take: Int, where: CountryWhereInput): Country
  findFirstCustomer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstCustomerOrThrow(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstFilm(cursor: FilmWhereUniqueInput, distinct: [FilmScalarFieldEnum!], orderBy: [FilmOrderByWithRelationInput!], skip: Int, take: Int, where: FilmWhereInput): Film
  findFirstFilmOrThrow(cursor: FilmWhereUniqueInput, distinct: [FilmScalarFieldEnum!], orderBy: [FilmOrderByWithRelationInput!], skip: Int, take: Int, where: FilmWhereInput): Film
  findFirstFilm_actor(cursor: Film_actorWhereUniqueInput, distinct: [Film_actorScalarFieldEnum!], orderBy: [Film_actorOrderByWithRelationInput!], skip: Int, take: Int, where: Film_actorWhereInput): Film_actor
  findFirstFilm_actorOrThrow(cursor: Film_actorWhereUniqueInput, distinct: [Film_actorScalarFieldEnum!], orderBy: [Film_actorOrderByWithRelationInput!], skip: Int, take: Int, where: Film_actorWhereInput): Film_actor
  findFirstFilm_category(cursor: Film_categoryWhereUniqueInput, distinct: [Film_categoryScalarFieldEnum!], orderBy: [Film_categoryOrderByWithRelationInput!], skip: Int, take: Int, where: Film_categoryWhereInput): Film_category
  findFirstFilm_categoryOrThrow(cursor: Film_categoryWhereUniqueInput, distinct: [Film_categoryScalarFieldEnum!], orderBy: [Film_categoryOrderByWithRelationInput!], skip: Int, take: Int, where: Film_categoryWhereInput): Film_category
  findFirstFilm_text(cursor: Film_textWhereUniqueInput, distinct: [Film_textScalarFieldEnum!], orderBy: [Film_textOrderByWithRelationInput!], skip: Int, take: Int, where: Film_textWhereInput): Film_text
  findFirstFilm_textOrThrow(cursor: Film_textWhereUniqueInput, distinct: [Film_textScalarFieldEnum!], orderBy: [Film_textOrderByWithRelationInput!], skip: Int, take: Int, where: Film_textWhereInput): Film_text
  findFirstInventory(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): Inventory
  findFirstInventoryOrThrow(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): Inventory
  findFirstLanguage(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationInput!], skip: Int, take: Int, where: LanguageWhereInput): Language
  findFirstLanguageOrThrow(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationInput!], skip: Int, take: Int, where: LanguageWhereInput): Language
  findFirstPayment(cursor: PaymentWhereUniqueInput, distinct: [PaymentScalarFieldEnum!], orderBy: [PaymentOrderByWithRelationInput!], skip: Int, take: Int, where: PaymentWhereInput): Payment
  findFirstPaymentOrThrow(cursor: PaymentWhereUniqueInput, distinct: [PaymentScalarFieldEnum!], orderBy: [PaymentOrderByWithRelationInput!], skip: Int, take: Int, where: PaymentWhereInput): Payment
  findFirstRental(cursor: RentalWhereUniqueInput, distinct: [RentalScalarFieldEnum!], orderBy: [RentalOrderByWithRelationInput!], skip: Int, take: Int, where: RentalWhereInput): Rental
  findFirstRentalOrThrow(cursor: RentalWhereUniqueInput, distinct: [RentalScalarFieldEnum!], orderBy: [RentalOrderByWithRelationInput!], skip: Int, take: Int, where: RentalWhereInput): Rental
  findFirstStaff(cursor: StaffWhereUniqueInput, distinct: [StaffScalarFieldEnum!], orderBy: [StaffOrderByWithRelationInput!], skip: Int, take: Int, where: StaffWhereInput): Staff
  findFirstStaffOrThrow(cursor: StaffWhereUniqueInput, distinct: [StaffScalarFieldEnum!], orderBy: [StaffOrderByWithRelationInput!], skip: Int, take: Int, where: StaffWhereInput): Staff
  findFirstStore(cursor: StoreWhereUniqueInput, distinct: [StoreScalarFieldEnum!], orderBy: [StoreOrderByWithRelationInput!], skip: Int, take: Int, where: StoreWhereInput): Store
  findFirstStoreOrThrow(cursor: StoreWhereUniqueInput, distinct: [StoreScalarFieldEnum!], orderBy: [StoreOrderByWithRelationInput!], skip: Int, take: Int, where: StoreWhereInput): Store
  findManyStaff(cursor: StaffWhereUniqueInput, distinct: [StaffScalarFieldEnum!], orderBy: [StaffOrderByWithRelationInput!], skip: Int, take: Int, where: StaffWhereInput): [Staff!]!
  findUniqueStaff(where: StaffWhereUniqueInput!): Staff
  findUniqueStaffOrThrow(where: StaffWhereUniqueInput!): Staff
  getActor(where: ActorWhereUniqueInput!): Actor
  getAddress(where: AddressWhereUniqueInput!): Address
  getCategory(where: CategoryWhereUniqueInput!): Category
  getCity(where: CityWhereUniqueInput!): City
  getCountry(where: CountryWhereUniqueInput!): Country
  getCustomer(where: CustomerWhereUniqueInput!): Customer
  getFilm(where: FilmWhereUniqueInput!): Film
  getFilm_actor(where: Film_actorWhereUniqueInput!): Film_actor
  getFilm_category(where: Film_categoryWhereUniqueInput!): Film_category
  getFilm_text(where: Film_textWhereUniqueInput!): Film_text
  getInventory(where: InventoryWhereUniqueInput!): Inventory
  getLanguage(where: LanguageWhereUniqueInput!): Language
  getPayment(where: PaymentWhereUniqueInput!): Payment
  getRental(where: RentalWhereUniqueInput!): Rental
  getStore(where: StoreWhereUniqueInput!): Store
  groupByActor(by: [ActorScalarFieldEnum!]!, having: ActorScalarWhereWithAggregatesInput, orderBy: [ActorOrderByWithAggregationInput!], skip: Int, take: Int, where: ActorWhereInput): [ActorGroupBy!]!
  groupByAddress(by: [AddressScalarFieldEnum!]!, having: AddressScalarWhereWithAggregatesInput, orderBy: [AddressOrderByWithAggregationInput!], skip: Int, take: Int, where: AddressWhereInput): [AddressGroupBy!]!
  groupByCategory(by: [CategoryScalarFieldEnum!]!, having: CategoryScalarWhereWithAggregatesInput, orderBy: [CategoryOrderByWithAggregationInput!], skip: Int, take: Int, where: CategoryWhereInput): [CategoryGroupBy!]!
  groupByCity(by: [CityScalarFieldEnum!]!, having: CityScalarWhereWithAggregatesInput, orderBy: [CityOrderByWithAggregationInput!], skip: Int, take: Int, where: CityWhereInput): [CityGroupBy!]!
  groupByCountry(by: [CountryScalarFieldEnum!]!, having: CountryScalarWhereWithAggregatesInput, orderBy: [CountryOrderByWithAggregationInput!], skip: Int, take: Int, where: CountryWhereInput): [CountryGroupBy!]!
  groupByCustomer(by: [CustomerScalarFieldEnum!]!, having: CustomerScalarWhereWithAggregatesInput, orderBy: [CustomerOrderByWithAggregationInput!], skip: Int, take: Int, where: CustomerWhereInput): [CustomerGroupBy!]!
  groupByFilm(by: [FilmScalarFieldEnum!]!, having: FilmScalarWhereWithAggregatesInput, orderBy: [FilmOrderByWithAggregationInput!], skip: Int, take: Int, where: FilmWhereInput): [FilmGroupBy!]!
  groupByFilm_actor(by: [Film_actorScalarFieldEnum!]!, having: Film_actorScalarWhereWithAggregatesInput, orderBy: [Film_actorOrderByWithAggregationInput!], skip: Int, take: Int, where: Film_actorWhereInput): [Film_actorGroupBy!]!
  groupByFilm_category(by: [Film_categoryScalarFieldEnum!]!, having: Film_categoryScalarWhereWithAggregatesInput, orderBy: [Film_categoryOrderByWithAggregationInput!], skip: Int, take: Int, where: Film_categoryWhereInput): [Film_categoryGroupBy!]!
  groupByFilm_text(by: [Film_textScalarFieldEnum!]!, having: Film_textScalarWhereWithAggregatesInput, orderBy: [Film_textOrderByWithAggregationInput!], skip: Int, take: Int, where: Film_textWhereInput): [Film_textGroupBy!]!
  groupByInventory(by: [InventoryScalarFieldEnum!]!, having: InventoryScalarWhereWithAggregatesInput, orderBy: [InventoryOrderByWithAggregationInput!], skip: Int, take: Int, where: InventoryWhereInput): [InventoryGroupBy!]!
  groupByLanguage(by: [LanguageScalarFieldEnum!]!, having: LanguageScalarWhereWithAggregatesInput, orderBy: [LanguageOrderByWithAggregationInput!], skip: Int, take: Int, where: LanguageWhereInput): [LanguageGroupBy!]!
  groupByPayment(by: [PaymentScalarFieldEnum!]!, having: PaymentScalarWhereWithAggregatesInput, orderBy: [PaymentOrderByWithAggregationInput!], skip: Int, take: Int, where: PaymentWhereInput): [PaymentGroupBy!]!
  groupByRental(by: [RentalScalarFieldEnum!]!, having: RentalScalarWhereWithAggregatesInput, orderBy: [RentalOrderByWithAggregationInput!], skip: Int, take: Int, where: RentalWhereInput): [RentalGroupBy!]!
  groupByStaff(by: [StaffScalarFieldEnum!]!, having: StaffScalarWhereWithAggregatesInput, orderBy: [StaffOrderByWithAggregationInput!], skip: Int, take: Int, where: StaffWhereInput): [StaffGroupBy!]!
  groupByStore(by: [StoreScalarFieldEnum!]!, having: StoreScalarWhereWithAggregatesInput, orderBy: [StoreOrderByWithAggregationInput!], skip: Int, take: Int, where: StoreWhereInput): [StoreGroupBy!]!
  inventories(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): [Inventory!]!
  inventory(where: InventoryWhereUniqueInput!): Inventory
  language(where: LanguageWhereUniqueInput!): Language
  languages(cursor: LanguageWhereUniqueInput, distinct: [LanguageScalarFieldEnum!], orderBy: [LanguageOrderByWithRelationInput!], skip: Int, take: Int, where: LanguageWhereInput): [Language!]!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(cursor: PaymentWhereUniqueInput, distinct: [PaymentScalarFieldEnum!], orderBy: [PaymentOrderByWithRelationInput!], skip: Int, take: Int, where: PaymentWhereInput): [Payment!]!
  rental(where: RentalWhereUniqueInput!): Rental
  rentals(cursor: RentalWhereUniqueInput, distinct: [RentalScalarFieldEnum!], orderBy: [RentalOrderByWithRelationInput!], skip: Int, take: Int, where: RentalWhereInput): [Rental!]!
  store(where: StoreWhereUniqueInput!): Store
  stores(cursor: StoreWhereUniqueInput, distinct: [StoreScalarFieldEnum!], orderBy: [StoreOrderByWithRelationInput!], skip: Int, take: Int, where: StoreWhereInput): [Store!]!
}

type Rental {
  _count: RentalCount
  customer: Customer!
  customer_id: Int!
  inventory: Inventory!
  inventory_id: Int!
  last_update: DateTimeISO!
  payment(cursor: PaymentWhereUniqueInput, distinct: [PaymentScalarFieldEnum!], orderBy: [PaymentOrderByWithRelationInput!], skip: Int, take: Int, where: PaymentWhereInput): [Payment!]!
  rental_date: DateTimeISO!
  rental_id: Int!
  return_date: DateTimeISO
  staff: Staff!
  staff_id: Int!
}

type RentalAvgAggregate {
  customer_id: Float
  inventory_id: Float
  rental_id: Float
  staff_id: Float
}

input RentalAvgOrderByAggregateInput {
  customer_id: SortOrder
  inventory_id: SortOrder
  rental_id: SortOrder
  staff_id: SortOrder
}

type RentalCount {
  payment(where: PaymentWhereInput): Int!
}

type RentalCountAggregate {
  _all: Int!
  customer_id: Int!
  inventory_id: Int!
  last_update: Int!
  rental_date: Int!
  rental_id: Int!
  return_date: Int!
  staff_id: Int!
}

input RentalCountOrderByAggregateInput {
  customer_id: SortOrder
  inventory_id: SortOrder
  last_update: SortOrder
  rental_date: SortOrder
  rental_id: SortOrder
  return_date: SortOrder
  staff_id: SortOrder
}

input RentalCreateInput {
  customer: CustomerCreateNestedOneWithoutRentalInput!
  inventory: InventoryCreateNestedOneWithoutRentalInput!
  last_update: DateTimeISO
  payment: PaymentCreateNestedManyWithoutRentalInput
  rental_date: DateTimeISO!
  return_date: DateTimeISO
  staff: StaffCreateNestedOneWithoutRentalInput!
}

input RentalCreateManyCustomerInput {
  inventory_id: Int!
  last_update: DateTimeISO
  rental_date: DateTimeISO!
  rental_id: Int
  return_date: DateTimeISO
  staff_id: Int!
}

input RentalCreateManyCustomerInputEnvelope {
  data: [RentalCreateManyCustomerInput!]!
  skipDuplicates: Boolean
}

input RentalCreateManyInput {
  customer_id: Int!
  inventory_id: Int!
  last_update: DateTimeISO
  rental_date: DateTimeISO!
  rental_id: Int
  return_date: DateTimeISO
  staff_id: Int!
}

input RentalCreateManyInventoryInput {
  customer_id: Int!
  last_update: DateTimeISO
  rental_date: DateTimeISO!
  rental_id: Int
  return_date: DateTimeISO
  staff_id: Int!
}

input RentalCreateManyInventoryInputEnvelope {
  data: [RentalCreateManyInventoryInput!]!
  skipDuplicates: Boolean
}

input RentalCreateManyStaffInput {
  customer_id: Int!
  inventory_id: Int!
  last_update: DateTimeISO
  rental_date: DateTimeISO!
  rental_id: Int
  return_date: DateTimeISO
}

input RentalCreateManyStaffInputEnvelope {
  data: [RentalCreateManyStaffInput!]!
  skipDuplicates: Boolean
}

input RentalCreateNestedManyWithoutCustomerInput {
  connect: [RentalWhereUniqueInput!]
  connectOrCreate: [RentalCreateOrConnectWithoutCustomerInput!]
  create: [RentalCreateWithoutCustomerInput!]
  createMany: RentalCreateManyCustomerInputEnvelope
}

input RentalCreateNestedManyWithoutInventoryInput {
  connect: [RentalWhereUniqueInput!]
  connectOrCreate: [RentalCreateOrConnectWithoutInventoryInput!]
  create: [RentalCreateWithoutInventoryInput!]
  createMany: RentalCreateManyInventoryInputEnvelope
}

input RentalCreateNestedManyWithoutStaffInput {
  connect: [RentalWhereUniqueInput!]
  connectOrCreate: [RentalCreateOrConnectWithoutStaffInput!]
  create: [RentalCreateWithoutStaffInput!]
  createMany: RentalCreateManyStaffInputEnvelope
}

input RentalCreateNestedOneWithoutPaymentInput {
  connect: RentalWhereUniqueInput
  connectOrCreate: RentalCreateOrConnectWithoutPaymentInput
  create: RentalCreateWithoutPaymentInput
}

input RentalCreateOrConnectWithoutCustomerInput {
  create: RentalCreateWithoutCustomerInput!
  where: RentalWhereUniqueInput!
}

input RentalCreateOrConnectWithoutInventoryInput {
  create: RentalCreateWithoutInventoryInput!
  where: RentalWhereUniqueInput!
}

input RentalCreateOrConnectWithoutPaymentInput {
  create: RentalCreateWithoutPaymentInput!
  where: RentalWhereUniqueInput!
}

input RentalCreateOrConnectWithoutStaffInput {
  create: RentalCreateWithoutStaffInput!
  where: RentalWhereUniqueInput!
}

input RentalCreateWithoutCustomerInput {
  inventory: InventoryCreateNestedOneWithoutRentalInput!
  last_update: DateTimeISO
  payment: PaymentCreateNestedManyWithoutRentalInput
  rental_date: DateTimeISO!
  return_date: DateTimeISO
  staff: StaffCreateNestedOneWithoutRentalInput!
}

input RentalCreateWithoutInventoryInput {
  customer: CustomerCreateNestedOneWithoutRentalInput!
  last_update: DateTimeISO
  payment: PaymentCreateNestedManyWithoutRentalInput
  rental_date: DateTimeISO!
  return_date: DateTimeISO
  staff: StaffCreateNestedOneWithoutRentalInput!
}

input RentalCreateWithoutPaymentInput {
  customer: CustomerCreateNestedOneWithoutRentalInput!
  inventory: InventoryCreateNestedOneWithoutRentalInput!
  last_update: DateTimeISO
  rental_date: DateTimeISO!
  return_date: DateTimeISO
  staff: StaffCreateNestedOneWithoutRentalInput!
}

input RentalCreateWithoutStaffInput {
  customer: CustomerCreateNestedOneWithoutRentalInput!
  inventory: InventoryCreateNestedOneWithoutRentalInput!
  last_update: DateTimeISO
  payment: PaymentCreateNestedManyWithoutRentalInput
  rental_date: DateTimeISO!
  return_date: DateTimeISO
}

type RentalGroupBy {
  _avg: RentalAvgAggregate
  _count: RentalCountAggregate
  _max: RentalMaxAggregate
  _min: RentalMinAggregate
  _sum: RentalSumAggregate
  customer_id: Int!
  inventory_id: Int!
  last_update: DateTimeISO!
  rental_date: DateTimeISO!
  rental_id: Int!
  return_date: DateTimeISO
  staff_id: Int!
}

input RentalListRelationFilter {
  every: RentalWhereInput
  none: RentalWhereInput
  some: RentalWhereInput
}

type RentalMaxAggregate {
  customer_id: Int
  inventory_id: Int
  last_update: DateTimeISO
  rental_date: DateTimeISO
  rental_id: Int
  return_date: DateTimeISO
  staff_id: Int
}

input RentalMaxOrderByAggregateInput {
  customer_id: SortOrder
  inventory_id: SortOrder
  last_update: SortOrder
  rental_date: SortOrder
  rental_id: SortOrder
  return_date: SortOrder
  staff_id: SortOrder
}

type RentalMinAggregate {
  customer_id: Int
  inventory_id: Int
  last_update: DateTimeISO
  rental_date: DateTimeISO
  rental_id: Int
  return_date: DateTimeISO
  staff_id: Int
}

input RentalMinOrderByAggregateInput {
  customer_id: SortOrder
  inventory_id: SortOrder
  last_update: SortOrder
  rental_date: SortOrder
  rental_id: SortOrder
  return_date: SortOrder
  staff_id: SortOrder
}

input RentalNullableRelationFilter {
  is: RentalWhereInput
  isNot: RentalWhereInput
}

input RentalOrderByRelationAggregateInput {
  _count: SortOrder
}

input RentalOrderByWithAggregationInput {
  _avg: RentalAvgOrderByAggregateInput
  _count: RentalCountOrderByAggregateInput
  _max: RentalMaxOrderByAggregateInput
  _min: RentalMinOrderByAggregateInput
  _sum: RentalSumOrderByAggregateInput
  customer_id: SortOrder
  inventory_id: SortOrder
  last_update: SortOrder
  rental_date: SortOrder
  rental_id: SortOrder
  return_date: SortOrderInput
  staff_id: SortOrder
}

input RentalOrderByWithRelationInput {
  customer: CustomerOrderByWithRelationInput
  customer_id: SortOrder
  inventory: InventoryOrderByWithRelationInput
  inventory_id: SortOrder
  last_update: SortOrder
  payment: PaymentOrderByRelationAggregateInput
  rental_date: SortOrder
  rental_id: SortOrder
  return_date: SortOrderInput
  staff: StaffOrderByWithRelationInput
  staff_id: SortOrder
}

enum RentalScalarFieldEnum {
  customer_id
  inventory_id
  last_update
  rental_date
  rental_id
  return_date
  staff_id
}

input RentalScalarWhereInput {
  AND: [RentalScalarWhereInput!]
  NOT: [RentalScalarWhereInput!]
  OR: [RentalScalarWhereInput!]
  customer_id: IntFilter
  inventory_id: IntFilter
  last_update: DateTimeFilter
  rental_date: DateTimeFilter
  rental_id: IntFilter
  return_date: DateTimeNullableFilter
  staff_id: IntFilter
}

input RentalScalarWhereWithAggregatesInput {
  AND: [RentalScalarWhereWithAggregatesInput!]
  NOT: [RentalScalarWhereWithAggregatesInput!]
  OR: [RentalScalarWhereWithAggregatesInput!]
  customer_id: IntWithAggregatesFilter
  inventory_id: IntWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
  rental_date: DateTimeWithAggregatesFilter
  rental_id: IntWithAggregatesFilter
  return_date: DateTimeNullableWithAggregatesFilter
  staff_id: IntWithAggregatesFilter
}

type RentalSumAggregate {
  customer_id: Int
  inventory_id: Int
  rental_id: Int
  staff_id: Int
}

input RentalSumOrderByAggregateInput {
  customer_id: SortOrder
  inventory_id: SortOrder
  rental_id: SortOrder
  staff_id: SortOrder
}

input RentalUpdateInput {
  customer: CustomerUpdateOneRequiredWithoutRentalNestedInput
  inventory: InventoryUpdateOneRequiredWithoutRentalNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutRentalNestedInput
  rental_date: DateTimeFieldUpdateOperationsInput
  return_date: NullableDateTimeFieldUpdateOperationsInput
  staff: StaffUpdateOneRequiredWithoutRentalNestedInput
}

input RentalUpdateManyMutationInput {
  last_update: DateTimeFieldUpdateOperationsInput
  rental_date: DateTimeFieldUpdateOperationsInput
  return_date: NullableDateTimeFieldUpdateOperationsInput
}

input RentalUpdateManyWithWhereWithoutCustomerInput {
  data: RentalUpdateManyMutationInput!
  where: RentalScalarWhereInput!
}

input RentalUpdateManyWithWhereWithoutInventoryInput {
  data: RentalUpdateManyMutationInput!
  where: RentalScalarWhereInput!
}

input RentalUpdateManyWithWhereWithoutStaffInput {
  data: RentalUpdateManyMutationInput!
  where: RentalScalarWhereInput!
}

input RentalUpdateManyWithoutCustomerNestedInput {
  connect: [RentalWhereUniqueInput!]
  connectOrCreate: [RentalCreateOrConnectWithoutCustomerInput!]
  create: [RentalCreateWithoutCustomerInput!]
  createMany: RentalCreateManyCustomerInputEnvelope
  delete: [RentalWhereUniqueInput!]
  deleteMany: [RentalScalarWhereInput!]
  disconnect: [RentalWhereUniqueInput!]
  set: [RentalWhereUniqueInput!]
  update: [RentalUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [RentalUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [RentalUpsertWithWhereUniqueWithoutCustomerInput!]
}

input RentalUpdateManyWithoutInventoryNestedInput {
  connect: [RentalWhereUniqueInput!]
  connectOrCreate: [RentalCreateOrConnectWithoutInventoryInput!]
  create: [RentalCreateWithoutInventoryInput!]
  createMany: RentalCreateManyInventoryInputEnvelope
  delete: [RentalWhereUniqueInput!]
  deleteMany: [RentalScalarWhereInput!]
  disconnect: [RentalWhereUniqueInput!]
  set: [RentalWhereUniqueInput!]
  update: [RentalUpdateWithWhereUniqueWithoutInventoryInput!]
  updateMany: [RentalUpdateManyWithWhereWithoutInventoryInput!]
  upsert: [RentalUpsertWithWhereUniqueWithoutInventoryInput!]
}

input RentalUpdateManyWithoutStaffNestedInput {
  connect: [RentalWhereUniqueInput!]
  connectOrCreate: [RentalCreateOrConnectWithoutStaffInput!]
  create: [RentalCreateWithoutStaffInput!]
  createMany: RentalCreateManyStaffInputEnvelope
  delete: [RentalWhereUniqueInput!]
  deleteMany: [RentalScalarWhereInput!]
  disconnect: [RentalWhereUniqueInput!]
  set: [RentalWhereUniqueInput!]
  update: [RentalUpdateWithWhereUniqueWithoutStaffInput!]
  updateMany: [RentalUpdateManyWithWhereWithoutStaffInput!]
  upsert: [RentalUpsertWithWhereUniqueWithoutStaffInput!]
}

input RentalUpdateOneWithoutPaymentNestedInput {
  connect: RentalWhereUniqueInput
  connectOrCreate: RentalCreateOrConnectWithoutPaymentInput
  create: RentalCreateWithoutPaymentInput
  delete: RentalWhereInput
  disconnect: RentalWhereInput
  update: RentalUpdateToOneWithWhereWithoutPaymentInput
  upsert: RentalUpsertWithoutPaymentInput
}

input RentalUpdateToOneWithWhereWithoutPaymentInput {
  data: RentalUpdateWithoutPaymentInput!
  where: RentalWhereInput
}

input RentalUpdateWithWhereUniqueWithoutCustomerInput {
  data: RentalUpdateWithoutCustomerInput!
  where: RentalWhereUniqueInput!
}

input RentalUpdateWithWhereUniqueWithoutInventoryInput {
  data: RentalUpdateWithoutInventoryInput!
  where: RentalWhereUniqueInput!
}

input RentalUpdateWithWhereUniqueWithoutStaffInput {
  data: RentalUpdateWithoutStaffInput!
  where: RentalWhereUniqueInput!
}

input RentalUpdateWithoutCustomerInput {
  inventory: InventoryUpdateOneRequiredWithoutRentalNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutRentalNestedInput
  rental_date: DateTimeFieldUpdateOperationsInput
  return_date: NullableDateTimeFieldUpdateOperationsInput
  staff: StaffUpdateOneRequiredWithoutRentalNestedInput
}

input RentalUpdateWithoutInventoryInput {
  customer: CustomerUpdateOneRequiredWithoutRentalNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutRentalNestedInput
  rental_date: DateTimeFieldUpdateOperationsInput
  return_date: NullableDateTimeFieldUpdateOperationsInput
  staff: StaffUpdateOneRequiredWithoutRentalNestedInput
}

input RentalUpdateWithoutPaymentInput {
  customer: CustomerUpdateOneRequiredWithoutRentalNestedInput
  inventory: InventoryUpdateOneRequiredWithoutRentalNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  rental_date: DateTimeFieldUpdateOperationsInput
  return_date: NullableDateTimeFieldUpdateOperationsInput
  staff: StaffUpdateOneRequiredWithoutRentalNestedInput
}

input RentalUpdateWithoutStaffInput {
  customer: CustomerUpdateOneRequiredWithoutRentalNestedInput
  inventory: InventoryUpdateOneRequiredWithoutRentalNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutRentalNestedInput
  rental_date: DateTimeFieldUpdateOperationsInput
  return_date: NullableDateTimeFieldUpdateOperationsInput
}

input RentalUpsertWithWhereUniqueWithoutCustomerInput {
  create: RentalCreateWithoutCustomerInput!
  update: RentalUpdateWithoutCustomerInput!
  where: RentalWhereUniqueInput!
}

input RentalUpsertWithWhereUniqueWithoutInventoryInput {
  create: RentalCreateWithoutInventoryInput!
  update: RentalUpdateWithoutInventoryInput!
  where: RentalWhereUniqueInput!
}

input RentalUpsertWithWhereUniqueWithoutStaffInput {
  create: RentalCreateWithoutStaffInput!
  update: RentalUpdateWithoutStaffInput!
  where: RentalWhereUniqueInput!
}

input RentalUpsertWithoutPaymentInput {
  create: RentalCreateWithoutPaymentInput!
  update: RentalUpdateWithoutPaymentInput!
  where: RentalWhereInput
}

input RentalWhereInput {
  AND: [RentalWhereInput!]
  NOT: [RentalWhereInput!]
  OR: [RentalWhereInput!]
  customer: CustomerRelationFilter
  customer_id: IntFilter
  inventory: InventoryRelationFilter
  inventory_id: IntFilter
  last_update: DateTimeFilter
  payment: PaymentListRelationFilter
  rental_date: DateTimeFilter
  rental_id: IntFilter
  return_date: DateTimeNullableFilter
  staff: StaffRelationFilter
  staff_id: IntFilter
}

input RentalWhereUniqueInput {
  AND: [RentalWhereInput!]
  NOT: [RentalWhereInput!]
  OR: [RentalWhereInput!]
  customer: CustomerRelationFilter
  customer_id: IntFilter
  inventory: InventoryRelationFilter
  inventory_id: IntFilter
  last_update: DateTimeFilter
  payment: PaymentListRelationFilter
  rental_date: DateTimeFilter
  rental_date_inventory_id_customer_id: rentalRental_dateInventory_idCustomer_idCompoundUniqueInput
  rental_id: Int
  return_date: DateTimeNullableFilter
  staff: StaffRelationFilter
  staff_id: IntFilter
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

type Staff {
  _count: StaffCount
  active: Boolean!
  address: Address!
  address_id: Int!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO!
  password: String
  payment(cursor: PaymentWhereUniqueInput, distinct: [PaymentScalarFieldEnum!], orderBy: [PaymentOrderByWithRelationInput!], skip: Int, take: Int, where: PaymentWhereInput): [Payment!]!
  picture: Byte
  rental(cursor: RentalWhereUniqueInput, distinct: [RentalScalarFieldEnum!], orderBy: [RentalOrderByWithRelationInput!], skip: Int, take: Int, where: RentalWhereInput): [Rental!]!
  staff_id: Int!
  store_id: Int!
  store_staff_store_idTostore: Store!
  store_store_manager_staff_idTostaff(where: StoreWhereInput): Store
  username: String!
}

type StaffAvgAggregate {
  address_id: Float
  staff_id: Float
  store_id: Float
}

input StaffAvgOrderByAggregateInput {
  address_id: SortOrder
  staff_id: SortOrder
  store_id: SortOrder
}

type StaffCount {
  payment(where: PaymentWhereInput): Int!
  rental(where: RentalWhereInput): Int!
}

type StaffCountAggregate {
  _all: Int!
  active: Int!
  address_id: Int!
  email: Int!
  first_name: Int!
  last_name: Int!
  last_update: Int!
  password: Int!
  picture: Int!
  staff_id: Int!
  store_id: Int!
  username: Int!
}

input StaffCountOrderByAggregateInput {
  active: SortOrder
  address_id: SortOrder
  email: SortOrder
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
  password: SortOrder
  picture: SortOrder
  staff_id: SortOrder
  store_id: SortOrder
  username: SortOrder
}

input StaffCreateInput {
  active: Boolean
  address: AddressCreateNestedOneWithoutStaffInput!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  password: String
  payment: PaymentCreateNestedManyWithoutStaffInput
  picture: Byte
  rental: RentalCreateNestedManyWithoutStaffInput
  store_staff_store_idTostore: StoreCreateNestedOneWithoutStaff_staff_store_idTostoreInput!
  store_store_manager_staff_idTostaff: StoreCreateNestedOneWithoutStaff_store_manager_staff_idTostaffInput
  username: String!
}

input StaffCreateManyAddressInput {
  active: Boolean
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  password: String
  picture: Byte
  staff_id: Int
  store_id: Int!
  username: String!
}

input StaffCreateManyAddressInputEnvelope {
  data: [StaffCreateManyAddressInput!]!
  skipDuplicates: Boolean
}

input StaffCreateManyInput {
  active: Boolean
  address_id: Int!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  password: String
  picture: Byte
  staff_id: Int
  store_id: Int!
  username: String!
}

input StaffCreateManyStore_staff_store_idTostoreInput {
  active: Boolean
  address_id: Int!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  password: String
  picture: Byte
  staff_id: Int
  username: String!
}

input StaffCreateManyStore_staff_store_idTostoreInputEnvelope {
  data: [StaffCreateManyStore_staff_store_idTostoreInput!]!
  skipDuplicates: Boolean
}

input StaffCreateNestedManyWithoutStore_staff_store_idTostoreInput {
  connect: [StaffWhereUniqueInput!]
  connectOrCreate: [StaffCreateOrConnectWithoutStore_staff_store_idTostoreInput!]
  create: [StaffCreateWithoutStore_staff_store_idTostoreInput!]
  createMany: StaffCreateManyStore_staff_store_idTostoreInputEnvelope
}

input StaffCreateNestedOneWithoutPaymentInput {
  connect: StaffWhereUniqueInput
  connectOrCreate: StaffCreateOrConnectWithoutPaymentInput
  create: StaffCreateWithoutPaymentInput
}

input StaffCreateNestedOneWithoutRentalInput {
  connect: StaffWhereUniqueInput
  connectOrCreate: StaffCreateOrConnectWithoutRentalInput
  create: StaffCreateWithoutRentalInput
}

input StaffCreateNestedOneWithoutStore_store_manager_staff_idTostaffInput {
  connect: StaffWhereUniqueInput
  connectOrCreate: StaffCreateOrConnectWithoutStore_store_manager_staff_idTostaffInput
  create: StaffCreateWithoutStore_store_manager_staff_idTostaffInput
}

input StaffCreateOrConnectWithoutAddressInput {
  create: StaffCreateWithoutAddressInput!
  where: StaffWhereUniqueInput!
}

input StaffCreateOrConnectWithoutPaymentInput {
  create: StaffCreateWithoutPaymentInput!
  where: StaffWhereUniqueInput!
}

input StaffCreateOrConnectWithoutRentalInput {
  create: StaffCreateWithoutRentalInput!
  where: StaffWhereUniqueInput!
}

input StaffCreateOrConnectWithoutStore_staff_store_idTostoreInput {
  create: StaffCreateWithoutStore_staff_store_idTostoreInput!
  where: StaffWhereUniqueInput!
}

input StaffCreateOrConnectWithoutStore_store_manager_staff_idTostaffInput {
  create: StaffCreateWithoutStore_store_manager_staff_idTostaffInput!
  where: StaffWhereUniqueInput!
}

input StaffCreateWithoutAddressInput {
  active: Boolean
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  password: String
  payment: PaymentCreateNestedManyWithoutStaffInput
  picture: Byte
  rental: RentalCreateNestedManyWithoutStaffInput
  store_staff_store_idTostore: StoreCreateNestedOneWithoutStaff_staff_store_idTostoreInput!
  store_store_manager_staff_idTostaff: StoreCreateNestedOneWithoutStaff_store_manager_staff_idTostaffInput
  username: String!
}

input StaffCreateWithoutPaymentInput {
  active: Boolean
  address: AddressCreateNestedOneWithoutStaffInput!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  password: String
  picture: Byte
  rental: RentalCreateNestedManyWithoutStaffInput
  store_staff_store_idTostore: StoreCreateNestedOneWithoutStaff_staff_store_idTostoreInput!
  store_store_manager_staff_idTostaff: StoreCreateNestedOneWithoutStaff_store_manager_staff_idTostaffInput
  username: String!
}

input StaffCreateWithoutRentalInput {
  active: Boolean
  address: AddressCreateNestedOneWithoutStaffInput!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  password: String
  payment: PaymentCreateNestedManyWithoutStaffInput
  picture: Byte
  store_staff_store_idTostore: StoreCreateNestedOneWithoutStaff_staff_store_idTostoreInput!
  store_store_manager_staff_idTostaff: StoreCreateNestedOneWithoutStaff_store_manager_staff_idTostaffInput
  username: String!
}

input StaffCreateWithoutStore_staff_store_idTostoreInput {
  active: Boolean
  address: AddressCreateNestedOneWithoutStaffInput!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  password: String
  payment: PaymentCreateNestedManyWithoutStaffInput
  picture: Byte
  rental: RentalCreateNestedManyWithoutStaffInput
  store_store_manager_staff_idTostaff: StoreCreateNestedOneWithoutStaff_store_manager_staff_idTostaffInput
  username: String!
}

input StaffCreateWithoutStore_store_manager_staff_idTostaffInput {
  active: Boolean
  address: AddressCreateNestedOneWithoutStaffInput!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO
  password: String
  payment: PaymentCreateNestedManyWithoutStaffInput
  picture: Byte
  rental: RentalCreateNestedManyWithoutStaffInput
  store_staff_store_idTostore: StoreCreateNestedOneWithoutStaff_staff_store_idTostoreInput!
  username: String!
}

type StaffGroupBy {
  _avg: StaffAvgAggregate
  _count: StaffCountAggregate
  _max: StaffMaxAggregate
  _min: StaffMinAggregate
  _sum: StaffSumAggregate
  active: Boolean!
  address_id: Int!
  email: String
  first_name: String!
  last_name: String!
  last_update: DateTimeISO!
  password: String
  picture: Byte
  staff_id: Int!
  store_id: Int!
  username: String!
}

input StaffListRelationFilter {
  every: StaffWhereInput
  none: StaffWhereInput
  some: StaffWhereInput
}

type StaffMaxAggregate {
  active: Boolean
  address_id: Int
  email: String
  first_name: String
  last_name: String
  last_update: DateTimeISO
  password: String
  picture: Byte
  staff_id: Int
  store_id: Int
  username: String
}

input StaffMaxOrderByAggregateInput {
  active: SortOrder
  address_id: SortOrder
  email: SortOrder
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
  password: SortOrder
  picture: SortOrder
  staff_id: SortOrder
  store_id: SortOrder
  username: SortOrder
}

type StaffMinAggregate {
  active: Boolean
  address_id: Int
  email: String
  first_name: String
  last_name: String
  last_update: DateTimeISO
  password: String
  picture: Byte
  staff_id: Int
  store_id: Int
  username: String
}

input StaffMinOrderByAggregateInput {
  active: SortOrder
  address_id: SortOrder
  email: SortOrder
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
  password: SortOrder
  picture: SortOrder
  staff_id: SortOrder
  store_id: SortOrder
  username: SortOrder
}

input StaffOrderByRelationAggregateInput {
  _count: SortOrder
}

input StaffOrderByWithAggregationInput {
  _avg: StaffAvgOrderByAggregateInput
  _count: StaffCountOrderByAggregateInput
  _max: StaffMaxOrderByAggregateInput
  _min: StaffMinOrderByAggregateInput
  _sum: StaffSumOrderByAggregateInput
  active: SortOrder
  address_id: SortOrder
  email: SortOrderInput
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
  password: SortOrderInput
  picture: SortOrderInput
  staff_id: SortOrder
  store_id: SortOrder
  username: SortOrder
}

input StaffOrderByWithRelationInput {
  active: SortOrder
  address: AddressOrderByWithRelationInput
  address_id: SortOrder
  email: SortOrderInput
  first_name: SortOrder
  last_name: SortOrder
  last_update: SortOrder
  password: SortOrderInput
  payment: PaymentOrderByRelationAggregateInput
  picture: SortOrderInput
  rental: RentalOrderByRelationAggregateInput
  staff_id: SortOrder
  store_id: SortOrder
  store_staff_store_idTostore: StoreOrderByWithRelationInput
  store_store_manager_staff_idTostaff: StoreOrderByWithRelationInput
  username: SortOrder
}

input StaffRelationFilter {
  is: StaffWhereInput
  isNot: StaffWhereInput
}

enum StaffScalarFieldEnum {
  active
  address_id
  email
  first_name
  last_name
  last_update
  password
  picture
  staff_id
  store_id
  username
}

input StaffScalarWhereInput {
  AND: [StaffScalarWhereInput!]
  NOT: [StaffScalarWhereInput!]
  OR: [StaffScalarWhereInput!]
  active: BoolFilter
  address_id: IntFilter
  email: StringNullableFilter
  first_name: StringFilter
  last_name: StringFilter
  last_update: DateTimeFilter
  password: StringNullableFilter
  picture: BytesNullableFilter
  staff_id: IntFilter
  store_id: IntFilter
  username: StringFilter
}

input StaffScalarWhereWithAggregatesInput {
  AND: [StaffScalarWhereWithAggregatesInput!]
  NOT: [StaffScalarWhereWithAggregatesInput!]
  OR: [StaffScalarWhereWithAggregatesInput!]
  active: BoolWithAggregatesFilter
  address_id: IntWithAggregatesFilter
  email: StringNullableWithAggregatesFilter
  first_name: StringWithAggregatesFilter
  last_name: StringWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
  password: StringNullableWithAggregatesFilter
  picture: BytesNullableWithAggregatesFilter
  staff_id: IntWithAggregatesFilter
  store_id: IntWithAggregatesFilter
  username: StringWithAggregatesFilter
}

type StaffSumAggregate {
  address_id: Int
  staff_id: Int
  store_id: Int
}

input StaffSumOrderByAggregateInput {
  address_id: SortOrder
  staff_id: SortOrder
  store_id: SortOrder
}

input StaffUpdateInput {
  active: BoolFieldUpdateOperationsInput
  address: AddressUpdateOneRequiredWithoutStaffNestedInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutStaffNestedInput
  picture: NullableBytesFieldUpdateOperationsInput
  rental: RentalUpdateManyWithoutStaffNestedInput
  store_staff_store_idTostore: StoreUpdateOneRequiredWithoutStaff_staff_store_idTostoreNestedInput
  store_store_manager_staff_idTostaff: StoreUpdateOneWithoutStaff_store_manager_staff_idTostaffNestedInput
  username: StringFieldUpdateOperationsInput
}

input StaffUpdateManyMutationInput {
  active: BoolFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  picture: NullableBytesFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input StaffUpdateManyWithWhereWithoutAddressInput {
  data: StaffUpdateManyMutationInput!
  where: StaffScalarWhereInput!
}

input StaffUpdateManyWithWhereWithoutStore_staff_store_idTostoreInput {
  data: StaffUpdateManyMutationInput!
  where: StaffScalarWhereInput!
}

input StaffUpdateManyWithoutAddressNestedInput {
  connect: [StaffWhereUniqueInput!]
  connectOrCreate: [StaffCreateOrConnectWithoutAddressInput!]
  create: [StaffCreateWithoutAddressInput!]
  createMany: StaffCreateManyAddressInputEnvelope
  delete: [StaffWhereUniqueInput!]
  deleteMany: [StaffScalarWhereInput!]
  disconnect: [StaffWhereUniqueInput!]
  set: [StaffWhereUniqueInput!]
  update: [StaffUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [StaffUpdateManyWithWhereWithoutAddressInput!]
  upsert: [StaffUpsertWithWhereUniqueWithoutAddressInput!]
}

input StaffUpdateManyWithoutStore_staff_store_idTostoreNestedInput {
  connect: [StaffWhereUniqueInput!]
  connectOrCreate: [StaffCreateOrConnectWithoutStore_staff_store_idTostoreInput!]
  create: [StaffCreateWithoutStore_staff_store_idTostoreInput!]
  createMany: StaffCreateManyStore_staff_store_idTostoreInputEnvelope
  delete: [StaffWhereUniqueInput!]
  deleteMany: [StaffScalarWhereInput!]
  disconnect: [StaffWhereUniqueInput!]
  set: [StaffWhereUniqueInput!]
  update: [StaffUpdateWithWhereUniqueWithoutStore_staff_store_idTostoreInput!]
  updateMany: [StaffUpdateManyWithWhereWithoutStore_staff_store_idTostoreInput!]
  upsert: [StaffUpsertWithWhereUniqueWithoutStore_staff_store_idTostoreInput!]
}

input StaffUpdateOneRequiredWithoutPaymentNestedInput {
  connect: StaffWhereUniqueInput
  connectOrCreate: StaffCreateOrConnectWithoutPaymentInput
  create: StaffCreateWithoutPaymentInput
  update: StaffUpdateToOneWithWhereWithoutPaymentInput
  upsert: StaffUpsertWithoutPaymentInput
}

input StaffUpdateOneRequiredWithoutRentalNestedInput {
  connect: StaffWhereUniqueInput
  connectOrCreate: StaffCreateOrConnectWithoutRentalInput
  create: StaffCreateWithoutRentalInput
  update: StaffUpdateToOneWithWhereWithoutRentalInput
  upsert: StaffUpsertWithoutRentalInput
}

input StaffUpdateOneRequiredWithoutStore_store_manager_staff_idTostaffNestedInput {
  connect: StaffWhereUniqueInput
  connectOrCreate: StaffCreateOrConnectWithoutStore_store_manager_staff_idTostaffInput
  create: StaffCreateWithoutStore_store_manager_staff_idTostaffInput
  update: StaffUpdateToOneWithWhereWithoutStore_store_manager_staff_idTostaffInput
  upsert: StaffUpsertWithoutStore_store_manager_staff_idTostaffInput
}

input StaffUpdateToOneWithWhereWithoutPaymentInput {
  data: StaffUpdateWithoutPaymentInput!
  where: StaffWhereInput
}

input StaffUpdateToOneWithWhereWithoutRentalInput {
  data: StaffUpdateWithoutRentalInput!
  where: StaffWhereInput
}

input StaffUpdateToOneWithWhereWithoutStore_store_manager_staff_idTostaffInput {
  data: StaffUpdateWithoutStore_store_manager_staff_idTostaffInput!
  where: StaffWhereInput
}

input StaffUpdateWithWhereUniqueWithoutAddressInput {
  data: StaffUpdateWithoutAddressInput!
  where: StaffWhereUniqueInput!
}

input StaffUpdateWithWhereUniqueWithoutStore_staff_store_idTostoreInput {
  data: StaffUpdateWithoutStore_staff_store_idTostoreInput!
  where: StaffWhereUniqueInput!
}

input StaffUpdateWithoutAddressInput {
  active: BoolFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutStaffNestedInput
  picture: NullableBytesFieldUpdateOperationsInput
  rental: RentalUpdateManyWithoutStaffNestedInput
  store_staff_store_idTostore: StoreUpdateOneRequiredWithoutStaff_staff_store_idTostoreNestedInput
  store_store_manager_staff_idTostaff: StoreUpdateOneWithoutStaff_store_manager_staff_idTostaffNestedInput
  username: StringFieldUpdateOperationsInput
}

input StaffUpdateWithoutPaymentInput {
  active: BoolFieldUpdateOperationsInput
  address: AddressUpdateOneRequiredWithoutStaffNestedInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  picture: NullableBytesFieldUpdateOperationsInput
  rental: RentalUpdateManyWithoutStaffNestedInput
  store_staff_store_idTostore: StoreUpdateOneRequiredWithoutStaff_staff_store_idTostoreNestedInput
  store_store_manager_staff_idTostaff: StoreUpdateOneWithoutStaff_store_manager_staff_idTostaffNestedInput
  username: StringFieldUpdateOperationsInput
}

input StaffUpdateWithoutRentalInput {
  active: BoolFieldUpdateOperationsInput
  address: AddressUpdateOneRequiredWithoutStaffNestedInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutStaffNestedInput
  picture: NullableBytesFieldUpdateOperationsInput
  store_staff_store_idTostore: StoreUpdateOneRequiredWithoutStaff_staff_store_idTostoreNestedInput
  store_store_manager_staff_idTostaff: StoreUpdateOneWithoutStaff_store_manager_staff_idTostaffNestedInput
  username: StringFieldUpdateOperationsInput
}

input StaffUpdateWithoutStore_staff_store_idTostoreInput {
  active: BoolFieldUpdateOperationsInput
  address: AddressUpdateOneRequiredWithoutStaffNestedInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutStaffNestedInput
  picture: NullableBytesFieldUpdateOperationsInput
  rental: RentalUpdateManyWithoutStaffNestedInput
  store_store_manager_staff_idTostaff: StoreUpdateOneWithoutStaff_store_manager_staff_idTostaffNestedInput
  username: StringFieldUpdateOperationsInput
}

input StaffUpdateWithoutStore_store_manager_staff_idTostaffInput {
  active: BoolFieldUpdateOperationsInput
  address: AddressUpdateOneRequiredWithoutStaffNestedInput
  email: NullableStringFieldUpdateOperationsInput
  first_name: StringFieldUpdateOperationsInput
  last_name: StringFieldUpdateOperationsInput
  last_update: DateTimeFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  payment: PaymentUpdateManyWithoutStaffNestedInput
  picture: NullableBytesFieldUpdateOperationsInput
  rental: RentalUpdateManyWithoutStaffNestedInput
  store_staff_store_idTostore: StoreUpdateOneRequiredWithoutStaff_staff_store_idTostoreNestedInput
  username: StringFieldUpdateOperationsInput
}

input StaffUpsertWithWhereUniqueWithoutAddressInput {
  create: StaffCreateWithoutAddressInput!
  update: StaffUpdateWithoutAddressInput!
  where: StaffWhereUniqueInput!
}

input StaffUpsertWithWhereUniqueWithoutStore_staff_store_idTostoreInput {
  create: StaffCreateWithoutStore_staff_store_idTostoreInput!
  update: StaffUpdateWithoutStore_staff_store_idTostoreInput!
  where: StaffWhereUniqueInput!
}

input StaffUpsertWithoutPaymentInput {
  create: StaffCreateWithoutPaymentInput!
  update: StaffUpdateWithoutPaymentInput!
  where: StaffWhereInput
}

input StaffUpsertWithoutRentalInput {
  create: StaffCreateWithoutRentalInput!
  update: StaffUpdateWithoutRentalInput!
  where: StaffWhereInput
}

input StaffUpsertWithoutStore_store_manager_staff_idTostaffInput {
  create: StaffCreateWithoutStore_store_manager_staff_idTostaffInput!
  update: StaffUpdateWithoutStore_store_manager_staff_idTostaffInput!
  where: StaffWhereInput
}

input StaffWhereInput {
  AND: [StaffWhereInput!]
  NOT: [StaffWhereInput!]
  OR: [StaffWhereInput!]
  active: BoolFilter
  address: AddressRelationFilter
  address_id: IntFilter
  email: StringNullableFilter
  first_name: StringFilter
  last_name: StringFilter
  last_update: DateTimeFilter
  password: StringNullableFilter
  payment: PaymentListRelationFilter
  picture: BytesNullableFilter
  rental: RentalListRelationFilter
  staff_id: IntFilter
  store_id: IntFilter
  store_staff_store_idTostore: StoreRelationFilter
  store_store_manager_staff_idTostaff: StoreNullableRelationFilter
  username: StringFilter
}

input StaffWhereUniqueInput {
  AND: [StaffWhereInput!]
  NOT: [StaffWhereInput!]
  OR: [StaffWhereInput!]
  active: BoolFilter
  address: AddressRelationFilter
  address_id: IntFilter
  email: StringNullableFilter
  first_name: StringFilter
  last_name: StringFilter
  last_update: DateTimeFilter
  password: StringNullableFilter
  payment: PaymentListRelationFilter
  picture: BytesNullableFilter
  rental: RentalListRelationFilter
  staff_id: Int
  store_id: IntFilter
  store_staff_store_idTostore: StoreRelationFilter
  store_store_manager_staff_idTostaff: StoreNullableRelationFilter
  username: StringFilter
}

type Store {
  _count: StoreCount
  address: Address!
  address_id: Int!
  customer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  inventory(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): [Inventory!]!
  last_update: DateTimeISO!
  manager_staff_id: Int!
  staff_staff_store_idTostore(cursor: StaffWhereUniqueInput, distinct: [StaffScalarFieldEnum!], orderBy: [StaffOrderByWithRelationInput!], skip: Int, take: Int, where: StaffWhereInput): [Staff!]!
  staff_store_manager_staff_idTostaff: Staff!
  store_id: Int!
}

type StoreAvgAggregate {
  address_id: Float
  manager_staff_id: Float
  store_id: Float
}

input StoreAvgOrderByAggregateInput {
  address_id: SortOrder
  manager_staff_id: SortOrder
  store_id: SortOrder
}

type StoreCount {
  customer(where: CustomerWhereInput): Int!
  inventory(where: InventoryWhereInput): Int!
  staff_staff_store_idTostore(where: StaffWhereInput): Int!
}

type StoreCountAggregate {
  _all: Int!
  address_id: Int!
  last_update: Int!
  manager_staff_id: Int!
  store_id: Int!
}

input StoreCountOrderByAggregateInput {
  address_id: SortOrder
  last_update: SortOrder
  manager_staff_id: SortOrder
  store_id: SortOrder
}

input StoreCreateInput {
  address: AddressCreateNestedOneWithoutStoreInput!
  customer: CustomerCreateNestedManyWithoutStoreInput
  inventory: InventoryCreateNestedManyWithoutStoreInput
  last_update: DateTimeISO
  staff_staff_store_idTostore: StaffCreateNestedManyWithoutStore_staff_store_idTostoreInput
  staff_store_manager_staff_idTostaff: StaffCreateNestedOneWithoutStore_store_manager_staff_idTostaffInput!
}

input StoreCreateManyAddressInput {
  last_update: DateTimeISO
  manager_staff_id: Int!
  store_id: Int
}

input StoreCreateManyAddressInputEnvelope {
  data: [StoreCreateManyAddressInput!]!
  skipDuplicates: Boolean
}

input StoreCreateManyInput {
  address_id: Int!
  last_update: DateTimeISO
  manager_staff_id: Int!
  store_id: Int
}

input StoreCreateNestedOneWithoutCustomerInput {
  connect: StoreWhereUniqueInput
  connectOrCreate: StoreCreateOrConnectWithoutCustomerInput
  create: StoreCreateWithoutCustomerInput
}

input StoreCreateNestedOneWithoutInventoryInput {
  connect: StoreWhereUniqueInput
  connectOrCreate: StoreCreateOrConnectWithoutInventoryInput
  create: StoreCreateWithoutInventoryInput
}

input StoreCreateNestedOneWithoutStaff_staff_store_idTostoreInput {
  connect: StoreWhereUniqueInput
  connectOrCreate: StoreCreateOrConnectWithoutStaff_staff_store_idTostoreInput
  create: StoreCreateWithoutStaff_staff_store_idTostoreInput
}

input StoreCreateNestedOneWithoutStaff_store_manager_staff_idTostaffInput {
  connect: StoreWhereUniqueInput
  connectOrCreate: StoreCreateOrConnectWithoutStaff_store_manager_staff_idTostaffInput
  create: StoreCreateWithoutStaff_store_manager_staff_idTostaffInput
}

input StoreCreateOrConnectWithoutAddressInput {
  create: StoreCreateWithoutAddressInput!
  where: StoreWhereUniqueInput!
}

input StoreCreateOrConnectWithoutCustomerInput {
  create: StoreCreateWithoutCustomerInput!
  where: StoreWhereUniqueInput!
}

input StoreCreateOrConnectWithoutInventoryInput {
  create: StoreCreateWithoutInventoryInput!
  where: StoreWhereUniqueInput!
}

input StoreCreateOrConnectWithoutStaff_staff_store_idTostoreInput {
  create: StoreCreateWithoutStaff_staff_store_idTostoreInput!
  where: StoreWhereUniqueInput!
}

input StoreCreateOrConnectWithoutStaff_store_manager_staff_idTostaffInput {
  create: StoreCreateWithoutStaff_store_manager_staff_idTostaffInput!
  where: StoreWhereUniqueInput!
}

input StoreCreateWithoutAddressInput {
  customer: CustomerCreateNestedManyWithoutStoreInput
  inventory: InventoryCreateNestedManyWithoutStoreInput
  last_update: DateTimeISO
  staff_staff_store_idTostore: StaffCreateNestedManyWithoutStore_staff_store_idTostoreInput
  staff_store_manager_staff_idTostaff: StaffCreateNestedOneWithoutStore_store_manager_staff_idTostaffInput!
}

input StoreCreateWithoutCustomerInput {
  address: AddressCreateNestedOneWithoutStoreInput!
  inventory: InventoryCreateNestedManyWithoutStoreInput
  last_update: DateTimeISO
  staff_staff_store_idTostore: StaffCreateNestedManyWithoutStore_staff_store_idTostoreInput
  staff_store_manager_staff_idTostaff: StaffCreateNestedOneWithoutStore_store_manager_staff_idTostaffInput!
}

input StoreCreateWithoutInventoryInput {
  address: AddressCreateNestedOneWithoutStoreInput!
  customer: CustomerCreateNestedManyWithoutStoreInput
  last_update: DateTimeISO
  staff_staff_store_idTostore: StaffCreateNestedManyWithoutStore_staff_store_idTostoreInput
  staff_store_manager_staff_idTostaff: StaffCreateNestedOneWithoutStore_store_manager_staff_idTostaffInput!
}

input StoreCreateWithoutStaff_staff_store_idTostoreInput {
  address: AddressCreateNestedOneWithoutStoreInput!
  customer: CustomerCreateNestedManyWithoutStoreInput
  inventory: InventoryCreateNestedManyWithoutStoreInput
  last_update: DateTimeISO
  staff_store_manager_staff_idTostaff: StaffCreateNestedOneWithoutStore_store_manager_staff_idTostaffInput!
}

input StoreCreateWithoutStaff_store_manager_staff_idTostaffInput {
  address: AddressCreateNestedOneWithoutStoreInput!
  customer: CustomerCreateNestedManyWithoutStoreInput
  inventory: InventoryCreateNestedManyWithoutStoreInput
  last_update: DateTimeISO
  staff_staff_store_idTostore: StaffCreateNestedManyWithoutStore_staff_store_idTostoreInput
}

type StoreGroupBy {
  _avg: StoreAvgAggregate
  _count: StoreCountAggregate
  _max: StoreMaxAggregate
  _min: StoreMinAggregate
  _sum: StoreSumAggregate
  address_id: Int!
  last_update: DateTimeISO!
  manager_staff_id: Int!
  store_id: Int!
}

input StoreListRelationFilter {
  every: StoreWhereInput
  none: StoreWhereInput
  some: StoreWhereInput
}

type StoreMaxAggregate {
  address_id: Int
  last_update: DateTimeISO
  manager_staff_id: Int
  store_id: Int
}

input StoreMaxOrderByAggregateInput {
  address_id: SortOrder
  last_update: SortOrder
  manager_staff_id: SortOrder
  store_id: SortOrder
}

type StoreMinAggregate {
  address_id: Int
  last_update: DateTimeISO
  manager_staff_id: Int
  store_id: Int
}

input StoreMinOrderByAggregateInput {
  address_id: SortOrder
  last_update: SortOrder
  manager_staff_id: SortOrder
  store_id: SortOrder
}

input StoreNullableRelationFilter {
  is: StoreWhereInput
  isNot: StoreWhereInput
}

input StoreOrderByRelationAggregateInput {
  _count: SortOrder
}

input StoreOrderByWithAggregationInput {
  _avg: StoreAvgOrderByAggregateInput
  _count: StoreCountOrderByAggregateInput
  _max: StoreMaxOrderByAggregateInput
  _min: StoreMinOrderByAggregateInput
  _sum: StoreSumOrderByAggregateInput
  address_id: SortOrder
  last_update: SortOrder
  manager_staff_id: SortOrder
  store_id: SortOrder
}

input StoreOrderByWithRelationInput {
  address: AddressOrderByWithRelationInput
  address_id: SortOrder
  customer: CustomerOrderByRelationAggregateInput
  inventory: InventoryOrderByRelationAggregateInput
  last_update: SortOrder
  manager_staff_id: SortOrder
  staff_staff_store_idTostore: StaffOrderByRelationAggregateInput
  staff_store_manager_staff_idTostaff: StaffOrderByWithRelationInput
  store_id: SortOrder
}

input StoreRelationFilter {
  is: StoreWhereInput
  isNot: StoreWhereInput
}

enum StoreScalarFieldEnum {
  address_id
  last_update
  manager_staff_id
  store_id
}

input StoreScalarWhereInput {
  AND: [StoreScalarWhereInput!]
  NOT: [StoreScalarWhereInput!]
  OR: [StoreScalarWhereInput!]
  address_id: IntFilter
  last_update: DateTimeFilter
  manager_staff_id: IntFilter
  store_id: IntFilter
}

input StoreScalarWhereWithAggregatesInput {
  AND: [StoreScalarWhereWithAggregatesInput!]
  NOT: [StoreScalarWhereWithAggregatesInput!]
  OR: [StoreScalarWhereWithAggregatesInput!]
  address_id: IntWithAggregatesFilter
  last_update: DateTimeWithAggregatesFilter
  manager_staff_id: IntWithAggregatesFilter
  store_id: IntWithAggregatesFilter
}

type StoreSumAggregate {
  address_id: Int
  manager_staff_id: Int
  store_id: Int
}

input StoreSumOrderByAggregateInput {
  address_id: SortOrder
  manager_staff_id: SortOrder
  store_id: SortOrder
}

input StoreUpdateInput {
  address: AddressUpdateOneRequiredWithoutStoreNestedInput
  customer: CustomerUpdateManyWithoutStoreNestedInput
  inventory: InventoryUpdateManyWithoutStoreNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  staff_staff_store_idTostore: StaffUpdateManyWithoutStore_staff_store_idTostoreNestedInput
  staff_store_manager_staff_idTostaff: StaffUpdateOneRequiredWithoutStore_store_manager_staff_idTostaffNestedInput
}

input StoreUpdateManyMutationInput {
  last_update: DateTimeFieldUpdateOperationsInput
}

input StoreUpdateManyWithWhereWithoutAddressInput {
  data: StoreUpdateManyMutationInput!
  where: StoreScalarWhereInput!
}

input StoreUpdateManyWithoutAddressNestedInput {
  connect: [StoreWhereUniqueInput!]
  connectOrCreate: [StoreCreateOrConnectWithoutAddressInput!]
  create: [StoreCreateWithoutAddressInput!]
  createMany: StoreCreateManyAddressInputEnvelope
  delete: [StoreWhereUniqueInput!]
  deleteMany: [StoreScalarWhereInput!]
  disconnect: [StoreWhereUniqueInput!]
  set: [StoreWhereUniqueInput!]
  update: [StoreUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [StoreUpdateManyWithWhereWithoutAddressInput!]
  upsert: [StoreUpsertWithWhereUniqueWithoutAddressInput!]
}

input StoreUpdateOneRequiredWithoutCustomerNestedInput {
  connect: StoreWhereUniqueInput
  connectOrCreate: StoreCreateOrConnectWithoutCustomerInput
  create: StoreCreateWithoutCustomerInput
  update: StoreUpdateToOneWithWhereWithoutCustomerInput
  upsert: StoreUpsertWithoutCustomerInput
}

input StoreUpdateOneRequiredWithoutInventoryNestedInput {
  connect: StoreWhereUniqueInput
  connectOrCreate: StoreCreateOrConnectWithoutInventoryInput
  create: StoreCreateWithoutInventoryInput
  update: StoreUpdateToOneWithWhereWithoutInventoryInput
  upsert: StoreUpsertWithoutInventoryInput
}

input StoreUpdateOneRequiredWithoutStaff_staff_store_idTostoreNestedInput {
  connect: StoreWhereUniqueInput
  connectOrCreate: StoreCreateOrConnectWithoutStaff_staff_store_idTostoreInput
  create: StoreCreateWithoutStaff_staff_store_idTostoreInput
  update: StoreUpdateToOneWithWhereWithoutStaff_staff_store_idTostoreInput
  upsert: StoreUpsertWithoutStaff_staff_store_idTostoreInput
}

input StoreUpdateOneWithoutStaff_store_manager_staff_idTostaffNestedInput {
  connect: StoreWhereUniqueInput
  connectOrCreate: StoreCreateOrConnectWithoutStaff_store_manager_staff_idTostaffInput
  create: StoreCreateWithoutStaff_store_manager_staff_idTostaffInput
  delete: StoreWhereInput
  disconnect: StoreWhereInput
  update: StoreUpdateToOneWithWhereWithoutStaff_store_manager_staff_idTostaffInput
  upsert: StoreUpsertWithoutStaff_store_manager_staff_idTostaffInput
}

input StoreUpdateToOneWithWhereWithoutCustomerInput {
  data: StoreUpdateWithoutCustomerInput!
  where: StoreWhereInput
}

input StoreUpdateToOneWithWhereWithoutInventoryInput {
  data: StoreUpdateWithoutInventoryInput!
  where: StoreWhereInput
}

input StoreUpdateToOneWithWhereWithoutStaff_staff_store_idTostoreInput {
  data: StoreUpdateWithoutStaff_staff_store_idTostoreInput!
  where: StoreWhereInput
}

input StoreUpdateToOneWithWhereWithoutStaff_store_manager_staff_idTostaffInput {
  data: StoreUpdateWithoutStaff_store_manager_staff_idTostaffInput!
  where: StoreWhereInput
}

input StoreUpdateWithWhereUniqueWithoutAddressInput {
  data: StoreUpdateWithoutAddressInput!
  where: StoreWhereUniqueInput!
}

input StoreUpdateWithoutAddressInput {
  customer: CustomerUpdateManyWithoutStoreNestedInput
  inventory: InventoryUpdateManyWithoutStoreNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  staff_staff_store_idTostore: StaffUpdateManyWithoutStore_staff_store_idTostoreNestedInput
  staff_store_manager_staff_idTostaff: StaffUpdateOneRequiredWithoutStore_store_manager_staff_idTostaffNestedInput
}

input StoreUpdateWithoutCustomerInput {
  address: AddressUpdateOneRequiredWithoutStoreNestedInput
  inventory: InventoryUpdateManyWithoutStoreNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  staff_staff_store_idTostore: StaffUpdateManyWithoutStore_staff_store_idTostoreNestedInput
  staff_store_manager_staff_idTostaff: StaffUpdateOneRequiredWithoutStore_store_manager_staff_idTostaffNestedInput
}

input StoreUpdateWithoutInventoryInput {
  address: AddressUpdateOneRequiredWithoutStoreNestedInput
  customer: CustomerUpdateManyWithoutStoreNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  staff_staff_store_idTostore: StaffUpdateManyWithoutStore_staff_store_idTostoreNestedInput
  staff_store_manager_staff_idTostaff: StaffUpdateOneRequiredWithoutStore_store_manager_staff_idTostaffNestedInput
}

input StoreUpdateWithoutStaff_staff_store_idTostoreInput {
  address: AddressUpdateOneRequiredWithoutStoreNestedInput
  customer: CustomerUpdateManyWithoutStoreNestedInput
  inventory: InventoryUpdateManyWithoutStoreNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  staff_store_manager_staff_idTostaff: StaffUpdateOneRequiredWithoutStore_store_manager_staff_idTostaffNestedInput
}

input StoreUpdateWithoutStaff_store_manager_staff_idTostaffInput {
  address: AddressUpdateOneRequiredWithoutStoreNestedInput
  customer: CustomerUpdateManyWithoutStoreNestedInput
  inventory: InventoryUpdateManyWithoutStoreNestedInput
  last_update: DateTimeFieldUpdateOperationsInput
  staff_staff_store_idTostore: StaffUpdateManyWithoutStore_staff_store_idTostoreNestedInput
}

input StoreUpsertWithWhereUniqueWithoutAddressInput {
  create: StoreCreateWithoutAddressInput!
  update: StoreUpdateWithoutAddressInput!
  where: StoreWhereUniqueInput!
}

input StoreUpsertWithoutCustomerInput {
  create: StoreCreateWithoutCustomerInput!
  update: StoreUpdateWithoutCustomerInput!
  where: StoreWhereInput
}

input StoreUpsertWithoutInventoryInput {
  create: StoreCreateWithoutInventoryInput!
  update: StoreUpdateWithoutInventoryInput!
  where: StoreWhereInput
}

input StoreUpsertWithoutStaff_staff_store_idTostoreInput {
  create: StoreCreateWithoutStaff_staff_store_idTostoreInput!
  update: StoreUpdateWithoutStaff_staff_store_idTostoreInput!
  where: StoreWhereInput
}

input StoreUpsertWithoutStaff_store_manager_staff_idTostaffInput {
  create: StoreCreateWithoutStaff_store_manager_staff_idTostaffInput!
  update: StoreUpdateWithoutStaff_store_manager_staff_idTostaffInput!
  where: StoreWhereInput
}

input StoreWhereInput {
  AND: [StoreWhereInput!]
  NOT: [StoreWhereInput!]
  OR: [StoreWhereInput!]
  address: AddressRelationFilter
  address_id: IntFilter
  customer: CustomerListRelationFilter
  inventory: InventoryListRelationFilter
  last_update: DateTimeFilter
  manager_staff_id: IntFilter
  staff_staff_store_idTostore: StaffListRelationFilter
  staff_store_manager_staff_idTostaff: StaffRelationFilter
  store_id: IntFilter
}

input StoreWhereUniqueInput {
  AND: [StoreWhereInput!]
  NOT: [StoreWhereInput!]
  OR: [StoreWhereInput!]
  address: AddressRelationFilter
  address_id: IntFilter
  customer: CustomerListRelationFilter
  inventory: InventoryListRelationFilter
  last_update: DateTimeFilter
  manager_staff_id: Int
  staff_staff_store_idTostore: StaffListRelationFilter
  staff_store_manager_staff_idTostaff: StaffRelationFilter
  store_id: Int
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input film_actorActor_idFilm_idCompoundUniqueInput {
  actor_id: Int!
  film_id: Int!
}

input film_categoryFilm_idCategory_idCompoundUniqueInput {
  category_id: Int!
  film_id: Int!
}

enum film_rating {
  G
  NC_17
  PG
  PG_13
  R
}

input rentalRental_dateInventory_idCustomer_idCompoundUniqueInput {
  customer_id: Int!
  inventory_id: Int!
  rental_date: DateTimeISO!
}